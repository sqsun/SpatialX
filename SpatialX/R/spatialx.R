#####################################################################
## Package: SPATIALX, 
## Package includes: SpatialVG, for single-slice
## Version: 0.1.0
## Date: 2020-2-14
## Modified: 2020-2-22 04:50:39;2020-3-14 19:55:43;2022-6-4 09:26:03;2022-9-17 09:37:51;
## 2024-8-13 21:45:39
## Title : Spatially-aware expression analysis of spatially resolved transcriptomics
## Determining the spatially variable genes using Poisson mixed models and 
## spatially variable genes using logistic mixed models
## Authors: S.Q. Sun
## Contacts: sqsunsph@xjtu.edu.cn
##          Xi'an Jiaotong University, 
##          Center for Single-Cell Omics and Health, Department of Biostatistics
######################################################################


#' @include utilties.R
#' @importFrom Rcpp evalCpp
#' @useDynLib SpatialX
NULL

#' SpatialX: A Package for Spatial Transcriptomics Analysis
#'
#' This package provides tools for analyzing spatial transcriptomics data,
#' including spatial variable gene detection, data normalization, and
#' spatial pattern analysis.
#'
#' SpatialX Class
#'
#' @description
#' The SpatialX class is the central data structure for spatial multi-omics analysis,
#' serving as a container for multiple assays and their associated metadata, analysis
#' results, and computational parameters. It enables integrated analysis of diverse
#' spatial data types including transcriptomics, proteomics, epigenomics, and imaging data.
#'
#' @details
#' The SpatialX class provides a comprehensive framework for storing, analyzing, and
#' visualizing spatial molecular data. It supports:
#' \itemize{
#' \item Multi-assay integration (RNA, ATAC, protein, spatial, etc.)
#' \item Species-specific analysis and annotation
#' \item Comprehensive metadata management
#' \item Reproducible analysis workflows through command logging
#' \item Flexible storage of intermediate results and tool outputs
#' \item Parallel processing capabilities
#' }
#'
#' @slot assays A list of Assay objects for this project. Each assay represents a
#' different data modality (e.g., RNA, ATAC, Spatial) with its own
#' count matrices, normalized data, and assay-specific analyses.
#' @slot active.assay Name of the active, or default, assay; settable using
#' \code{\link{DefaultAssay}}. This determines which assay is
#' used by default in analysis functions.
#' @slot project.name Name of the project for organizational purposes and
#' result naming.
#' @slot res.path Default file path for saving analysis results, figures, and
#' exported data. Used by various plotting and export functions.
#' @slot species Species identifier used for analysis. Common values include
#' "hsa" (human), "mmu" (mouse), "rno" (rat), etc. Influences
#' gene annotation, pathway analysis, and species-specific tools.
#' @slot misc A list of miscellaneous information not fitting into other slots.
#' Can store experiment details, analysis parameters, or user-defined
#' metadata.
#' @slot num.core Number of CPU cores to use for parallel processing. Affects
#' functions that support parallel computation.
#' @slot version Version of SpatialX package specification this object was
#' built under. Important for reproducibility and compatibility
#' checks.
#' @slot commands A list of logged commands run on this \code{SpatialX} object.
#' Each entry typically contains the function call, parameters,
#' and timestamp for reproducibility.
#' @slot tools A list of miscellaneous data generated by other tools, should be
#' filled by developers only using. Stores
#' intermediate results from various analysis pipelines.
#'
#' @section Class Structure:
#' The SpatialX object organizes data hierarchically:
#' \describe{
#' \item{Assays}{Multiple data modalities, each as an Assay object}
#' \item{Metadata}{Project-level information and parameters}
#' \item{Analysis Results}{Stored in both assay-specific and project-level slots}
#' \item{Reproducibility}{Command history and version tracking}
#' }
#'
#' @section Common Operations:
#' \itemize{
#' \item \code{\link{CreateSpatialXObject}}: Create a new SpatialX object
#' \item \code{\link{DefaultAssay}}: Get/set the active assay
#' \item \code{\link{subset}}: Subset the object by cells or features
#' \item \code{\link{Version}}: Check object version
#' }
#'
#' @section Multi-assay Integration:
#' SpatialX supports seamless integration of multiple assays through:
#' \itemize{
#' \item Shared cell barcodes across assays
#' \item Coordinated subsetting and filtering
#' \item Cross-assay normalization and batch correction
#' \item Integrated visualization and analysis
#' }
#'
#' @name SpatialX-class
#' @rdname SpatialX-class
#'
#' @seealso
#' \code{\link{CreateSpatialXObject}},
#' \code{\link{DefaultAssay}}
#'
#' @examples
#' \dontrun{
#' # Create a new SpatialX object
#' spatialx_obj <- CreateSpatialXObject(
#' counts = count_matrix,
#' location = spatial_coords,
#' project = "MySpatialStudy",
#' species = "hsa"
#' )
#'
#' # Add a second assay
#' spatialx_obj <- AddAssay(
#' object = spatialx_obj,
#' assay = atac_assay,
#' assay.name = "ATAC"
#' )
#'
#' # Set active assay
#' DefaultAssay(spatialx_obj) <- "ATAC"
#'
#' # Check object version
#' Version(spatialx_obj)
#' }
#'
#' @exportClass SpatialX
#' 
SpatialX <- setClass(Class = 'SpatialX',
	slots = c(assays = 'list',
	          active.assay = 'character',
	          project.name = 'character',
	          res.path = "character",
	          species = "character",
	          misc = 'list',
	          num.core = 'numeric',
	          commands = 'list',
	          version = 'character',
	          tools = 'list'))

#' The Assay Class
#'
#' @description
#' The Assay object is the foundational data structure in SpatialX, serving as
#' the basic unit for storing and analyzing spatial molecular data. Each Assay
#' stores raw, normalized, and scaled data matrices along with spatial
#' coordinates, cluster information, variable features, and assay-specific
#' metadata. Assays can contain diverse data types including RNA-seq, ATAC-seq,
#' protein expression, spatial transcriptomics, and imputed data.
#'
#' @details
#' The Assay class provides a comprehensive framework for spatial data analysis,
#' integrating multiple data modalities and analysis results into a unified
#' structure. It supports:
#' \itemize{
#' \item Multi-modal data storage (raw, normalized, scaled)
#' \item Spatial coordinate management
#' \item Cell type deconvolution results
#' \item Spatial domain identification
#' \item Dimensionality reduction and clustering
#' \item Differential expression and spatial gene detection
#' \item Comprehensive metadata organization
#' }
#'
#' @slot counts Raw count data stored as a matrix, data.frame, or sparse matrix.
#' Features as rows, cells/spots as columns.
#' @slot data Normalized expression data (e.g., log-normalized counts). Same
#' dimensions as \code{counts}.
#' @slot scale.data Scaled expression data (e.g., z-scores) for dimensionality
#' reduction and visualization.
#' @slot location Spatial coordinates data.frame with x, y (and optionally z)
#' coordinates for each cell/spot.
#' @slot cell.prop Cell type proportion matrix for spatial deconvolution results.
#' Rows represent cell types, columns represent spatial spots.
#' @slot domain.clust Spatial domain or cluster assignments for each cell/spot.
#' Can be a vector, factor, or matrix.
#' @slot graph Neighborhood graph used for clustering and spatial analysis
#' (e.g., k-nearest neighbors, spatial graph).
#' @slot total.counts Total counts per cell/spot used for normalization and
#' model fitting.
#' @slot ident Primary identity labels for cells/spots (e.g., cluster assignments,
#' cell types). Stored as a factor.
#' @slot key Key prefix for the assay, used for feature naming and indexing.
#' @slot dr Dimensionality reduction results stored as a list. Each element
#' contains coordinates and metadata for a specific reduction (e.g., PCA, UMAP).
#' @slot de Differential expression analysis results stored as a data.frame.
#' @slot isvg Integrative spatially variable genes detected from multiple slices
#' or samples.
#' @slot csvg Cell-type specific spatially variable genes.
#' @slot dsvg Domain-specific spatially variable genes.
#' @slot tsvg Temporally variable genes for time-course spatial experiments.
#' @slot svg Overall spatially variable genes across all analyses.
#' @slot sv.genes Names or identifiers of spatially variable genes.
#' @slot de.truth Ground truth differential expression genes from simulation studies.
#' @slot images Associated image data or image coordinates for spatial assays.
#' @slot meta.data Cell-level metadata data.frame with rows corresponding to
#' cells/spots and columns containing metadata variables.
#' Automatically includes nFeature (number of features detected),
#' nCount (total counts), and orig.ident (original identity).
#' @slot meta.features Feature-level metadata data.frame with rows corresponding
#' to features (genes) and columns containing feature annotations.
#' @slot misc Miscellaneous information stored as a list for additional
#' assay-specific data and parameters.
#' @slot dea Differential expression analysis results in a structured data.frame.
#' @slot dec Cell type-specific differential expression or deconvolution results.
#'
#' @section Data Organization:
#' The Assay class maintains three main data matrices:
#' \describe{
#' \item{counts}{Raw, unprocessed data}
#' \item{data}{Normalized data for most analyses}
#' \item{scale.data}{Scaled data for dimensionality reduction}
#' }
#'
#' @section Spatial Analysis Features:
#' The class includes specialized slots for spatial analysis:
#' \describe{
#' \item{Spatial Coordinates}{Exact spatial locations of cells/spots}
#' \item{Cell Type Proportions}{Results from spatial deconvolution algorithms}
#' \item{Spatial Domains}{Tissue region classifications}
#' \item{Spatially Variable Genes}{Multiple types of spatial gene detection}
#' }
#'
#' @section Methods:
#' Common methods for Assay objects include:
#' \itemize{
#' \item \code{\link{CreateAssayObject}}: Constructor function
#' \item \code{\link{subset}}: Subsetting assays
#' \item \code{\link{AddMetaData}}: Adding metadata
#' }
#'
#' @name Assay-class
#' @rdname Assay-class
#'
#' @concept assay
#'
#' @seealso
#' \code{\link{CreateAssayObject}},
#' \code{\link{SpatialX-class}},
#' \code{\link{AddMetaData}}
#'
#' @examples
#' \dontrun{
#' # Create a new Assay object
#' assay_obj <- CreateAssayObject(counts = count_matrix)
#'
#' # Access assay data
#' raw_counts <- GetAssayData(assay_obj, slot = "counts")
#' normalized_data <- GetAssayData(assay_obj, slot = "data")
#'
#' # Add spatial coordinates
#' assay_obj@location <- spatial_coordinates
#'
#' # View metadata
#' cell_metadata <- assay_obj@meta.data
#' feature_metadata <- assay_obj@meta.features
#' }
#'
#' @exportClass Assay
#' 
Assay <- setClass(
	Class = "Assay",
		slots = c(
		counts = "ANY",
		location = "data.frame",
		data = "ANY",
		scale.data = "ANY",
		cell.prop = "ANY",
		domain.clust = "ANY",
		graph = "ANY",
		total.counts = "ANY",
		key = 'character',
		ident = "factor", ## cell type or clustering information
		meta.features = "data.frame",
		meta.data = "data.frame",
		dr = "list",
		de = "data.frame",
		isvg = "ANY",
		csvg = "ANY",
		dsvg = "ANY",
		tsvg = "ANY",
		svg = "ANY",
		sv.genes = "ANY",
		de.truth = "ANY",
		dea = "data.frame",
		dec = "data.frame",
		images = "ANY",
		misc = "ANY"))


###########################################
#' Create an Assay object from raw data
#'
#' @description
#' Create an Assay object from a feature (e.g., gene) expression matrix.
#' The expected format of the input matrix is features x cells. This function
#' provides a flexible way to initialize Assay objects with built-in data
#' validation and quality control filtering.
#'
#' @param counts Raw count data matrix with features as rows and cells as columns.
#' Can be a matrix, data.frame, or sparse matrix
#' @param data Pre-normalized data matrix (e.g., log-normalized, scaled). If
#' provided, do not pass \code{counts}. Should have the same
#' dimensions and feature/cell names as \code{counts} if both are
#' provided
#' @param min.cells Include features detected in at least this many cells.
#' Features with fewer detected cells will be filtered out.
#' To reintroduce excluded features, create a new object with
#' a lower cutoff (default: 0)
#' @param min.features Include cells where at least this many features are
#' detected. Cells with fewer features will be filtered out
#' (default: 0)
#' @param pct.cells Minimum percentage of cells in which a feature must be
#' detected to be included. Provides an alternative to
#' \code{min.cells} that scales with dataset size (default: 0.005)
#' @param min.umi Minimum UMI counts per cell. Cells with fewer UMIs will be
#' filtered out (default: 10)
#' @param num.core Number of CPU cores to use for parallel processing during
#' data validation and filtering (default: 1)
#' @param ... Additional arguments passed to internal methods
#'
#' @return Returns an \code{\link{Assay}} object containing the processed
#' count data, normalized data (if provided), and associated metadata
#'
#' @details
#' This function creates a standardized Assay object that serves as the
#' foundational data structure for various analysis workflows. Key features:
#' \itemize{
#' \item Supports both raw counts and pre-normalized data inputs
#' \item Performs comprehensive quality control filtering
#' \item Maintains data integrity through validation checks
#' \item Handles both dense and sparse matrix formats efficiently
#' \item Provides flexible filtering criteria for different data types
#' }
#'
#' The function applies filtering in two stages:
#' \enumerate{
#' \item Feature filtering: removes features detected in too few cells
#' \item Cell filtering: removes cells with too few features or UMIs
#' }
#'
#' When both \code{counts} and \code{data} are provided, they must have
#' identical dimensions and feature/cell names. The function validates this
#' consistency to prevent downstream analysis errors.
#'
#' @examples
#' \dontrun{
#' # Create Assay object from raw counts
#' counts_matrix <- matrix(rpois(1000, 1), nrow = 100, ncol = 10)
#' rownames(counts_matrix) <- paste0("Gene_", 1:100)
#' colnames(counts_matrix) <- paste0("Cell_", 1:10)
#'
#' assay_obj <- CreateAssayObject(
#' counts = counts_matrix,
#' min.cells = 3,
#' min.features = 200,
#' min.umi = 100
#' )
#'
#' # Create with pre-normalized data
#' normalized_data <- log1p(counts_matrix)
#' assay_obj <- CreateAssayObject(
#' counts = counts_matrix,
#' data = normalized_data,
#' pct.cells = 0.01
#' )
#'
#' # Create from sparse matrix
#' library(Matrix)
#' sparse_counts <- Matrix(counts_matrix, sparse = TRUE)
#' assay_obj <- CreateAssayObject(
#' counts = sparse_counts,
#' min.cells = 5
#' )
#' }
#'
#' @importFrom methods as
#' @importFrom methods new
#' @importFrom methods is
#' @importFrom Matrix colSums rowSums
#'
#' @seealso
#' \code{\link{Assay-class}}
#'
#' @export
#' 
CreateAssayObject <- function(counts,
                          		data,
                          		min.cells = 0,
                          		min.features = 0,
                          		pct.cells = 0.005,
                          		min.umi = 10,
                          		num.core = 1,...) {
	
	## inputs checking
	if (missing(x = counts) && missing(x = data)) {
		stop("Must provide either 'counts' or 'data'")
	} else if (!missing(x = counts) && !missing(x = data)) {
		stop("Either 'counts' or 'data' must be missing; both cannot be provided")
	} else if (!missing(x = counts)) {
		# check that dimnames of input counts are unique
		if (anyDuplicated(x = rownames(x = counts))) {
			warning(
				"Non-unique features (rownames) present in the input matrix, making unique",
				call. = FALSE,
				immediate. = TRUE)
			rownames(x = counts) <- make.unique(names = rownames(x = counts))
		}## end fi
		
		if (anyDuplicated(x = colnames(x = counts))) {
			warning(
				"Non-unique cell names (colnames) present in the input matrix, making unique",
				call. = FALSE,
				immediate. = TRUE)
			colnames(x = counts) <- make.unique(names = colnames(x = counts))
		}## end fi
	
		if (is.null(x = colnames(x = counts))) {
			stop("No cell names (colnames) names present in the input matrix")
		}## end fi
		
		if (any(rownames(x = counts) == '')) {
			stop("Feature names of counts matrix cannot be empty", call. = FALSE)
		}## end fi
		
		if (nrow(x = counts) > 0 && is.null(x = rownames(x = counts))) {
			stop("No feature names (rownames) names present in the input matrix")
		}## end fi

		if (!inherits(x = counts, what = 'dgCMatrix')) {
		  #counts <- as.sparse(x = counts, ...)
		  counts <- as(counts,"sparseMatrix")
		}## end fi

		## filtering out lowly expressed genes by percentage = 0.005
		if (pct.cells > 0){
			num.cells <- Matrix::rowSums(counts > 0)
			counts	<- counts[which(num.cells >= floor(pct.cells*ncol(counts))),]
		}## end fi
	
		## filter genes on the number of cells expressing
		if (min.cells > 0) {
			num.cells <- Matrix::rowSums(x = counts > 0)
			counts <- counts[which(x = num.cells >= min.cells), ]
		}## end fi
		
		## Filter based on min.features
		if (min.features > 0) {
			nfeatures <- Matrix::colSums(x = counts > 0)
			counts <- counts[, which(x = nfeatures >= min.features)]
		}## end fi
		
		if (min.umi > 0) {
			total.umi <- Matrix::colSums(x = counts)
			counts <- counts[, which(x = total.umi > min.umi)]
		}## end fi
		
		#data <- counts
		lib_size <- Matrix::colSums(counts)
		data <- log(sweep(counts, 2, lib_size, "/")*1e4 + 1.0)
	} else if (!missing(x = data)) {
		
		## check that dimnames of input data are unique
		if (anyDuplicated(x = rownames(x = data))) {
		  warning(
			"Non-unique features (rownames) present in the input matrix, making unique",
			call. = FALSE,
			immediate. = TRUE
		  )
		  rownames(x = data) <- make.unique(names = rownames(x = data))
		}
		if (anyDuplicated(x = colnames(x = data))) {
		  warning(
			"Non-unique cell names (colnames) present in the input matrix, making unique",
			call. = FALSE,
			immediate. = TRUE
		  )
		  colnames(x = data) <- make.unique(names = colnames(x = data))
		}
		if (is.null(x = colnames(x = data))) {
		  stop("No cell names (colnames) names present in the input matrix")
		}
		if (any(rownames(x = data) == '')) {
		  stop("Feature names of data matrix cannot be empty", call. = FALSE)
		}
		if (nrow(x = data) > 0 && is.null(x = rownames(x = data))) {
		  stop("No feature names (rownames) names present in the input matrix")
		}
		if (min.cells != 0 | min.features != 0) {
		  warning(
			"No filtering performed if passing to data rather than counts",
			call. = FALSE,
			immediate. = TRUE
		  )
		}
		counts <- new(Class = 'matrix')
	}## end fi

	## Ensure row- and column-names are vectors, not arrays
	if(!is.vector(x = rownames(x = counts))){rownames(x = counts) <- as.vector(x = rownames(x = counts))}
	if(!is.vector(x = colnames(x = counts))){colnames(x = counts) <- as.vector(x = colnames(x = counts))}
	if(!is.vector(x = rownames(x = data))){rownames(x = data) <- as.vector(x = rownames(x = data))}
	if(!is.vector(x = colnames(x = data))){colnames(x = data) <- as.vector(x = colnames(x = data))}
	if(any(grepl(pattern = '_', x = rownames(x = counts))) || any(grepl(pattern = '_', x = rownames(x = data)))) {
		## replace underscores _ with dashes -
		suppressWarnings(warning("Feature names cannot have underscores ('_'), replacing with dashes ('-')",call. = FALSE,immediate. = TRUE))
		## commands for row names and colnum names
		rownames(x = counts) <- gsub(pattern = '_',
		  replacement = '-',
		  x = rownames(x = counts)
		)
		rownames(x = data) <- gsub(pattern = '_',
		  replacement = '-',
		  x = rownames(x = data)
		)
	}## end fi
  
	##
	if(any(grepl(pattern = '|', x = rownames(x = counts), fixed = TRUE)) || any(grepl(pattern = '|', x = rownames(x = data), fixed = TRUE))) {
		warning(
		  "Feature names cannot have pipe characters ('|'), replacing with dashes ('-')",
		  call. = FALSE,
		  immediate. = TRUE)
		  
		rownames(x = counts) <- gsub(
		  pattern = '|',
		  replacement = '-',
		  x = rownames(x = counts),
		  fixed = TRUE)
		
		rownames(x = data) <- gsub(
		  pattern = '|',
		  replacement = '-',
		  x = rownames(x = data),
		  fixed = TRUE)
	}## end fi
	
	## Initialize meta.features
	init.meta.features <- data.frame(row.names = rownames(x = data))
	assay <- new(Class = 'Assay', counts = counts, data = data,
		scale.data = new(Class = 'matrix'),
		meta.features = init.meta.features,
		misc = list())
	return(assay)
}## end func



#' Create a SpatialX object from raw data
#'
#' @description
#' This is the default method for creating a SpatialX object from raw count data,
#' spatial coordinates, and associated metadata. It provides a comprehensive
#' framework for initializing spatial transcriptomics data with built-in
#' quality control and data validation.
#'
#' @param counts Raw count data. Can be a matrix, data.frame, or any matrix-like
#' object with features as rows and cells/spots as columns
#' @param location Spatial coordinates as a data.frame or matrix with rows
#' corresponding to cells/spots and columns for spatial coordinates
#' (typically x and y coordinates). Required for spatial analysis
#' @param cell.prop Cell type proportion matrix for spatial deconvolution, with
#' rows as cell types and columns as spatial spots. Used for
#' resolving cell type mixtures in spatial transcriptomics data
#' @param domain.clust Spatial domain or cluster assignments for each cell/spot.
#' Can be a vector, factor, or matrix with domain classifications
#' @param project Project name for the SpatialX object (default: 'SpatialX')
#' @param assay Name of the primary assay (default: 'RNA')
#' @param species Species identifier for the data. Common values: "hsa" (human),
#' "mmu" (mouse), "rno" (rat), etc. Used for species-specific
#' analysis and annotation (default: "hsa")
#' @param names.field Field index in cell names containing sample information
#' (default: 1)
#' @param names.delim Delimiter used in cell names to separate fields (default: '')
#' @param min.cells Include features detected in at least this many cells.
#' Features with fewer detected cells will be filtered out
#' (default: 0)
#' @param pct.cells Minimum percentage of cells in which a feature must be
#' detected to be included (default: 0.005)
#' @param min.features Include cells where at least this many features are
#' detected. Cells with fewer features will be filtered out
#' (default: 0)
#' @param min.umi Minimum UMI counts per cell. Cells with fewer UMIs will be
#' filtered out (default: 10)
#' @param num.core Number of CPU cores to use for parallel processing (default: 1)
#' @param row.names Optional vector of feature names to use when \code{counts}
#' is a \code{data.frame} or \code{data.frame}-derived object
#' without row names
#' @param version Version of SpatialX specification this object follows
#' (default: "0.0.1")
#' @param ... Additional arguments passed to internal processing functions
#'
#' @return Returns a fully initialized SpatialX object ready for spatial
#' transcriptomics analysis, containing:
#' \itemize{
#' \item Processed count matrix with quality control filters applied
#' \item Spatial coordinate information
#' \item Cell type proportion data (if provided)
#' \item Spatial domain assignments (if provided)
#' \item Species-specific annotations
#' \item Comprehensive metadata and version information
#' }
#'
#' @details
#' This default method provides the most flexible way to create SpatialX objects
#' from raw data inputs. It performs comprehensive data validation and quality
#' control, including:
#' \itemize{
#' \item Dimension matching between counts and spatial coordinates
#' \item Quality filtering based on multiple criteria (min.cells, pct.cells,
#' min.features, min.umi)
#' \item Species-specific gene annotation and validation
#' \item Integration of spatial deconvolution results
#' \item Spatial domain clustering and validation
#' \item Metadata organization and standardization
#' }
#'
#' The function automatically generates basic cell-level metadata including
#' number of features detected (nFeature), total counts (nCount), and sample
#' identifiers extracted from cell names.
#'
#' @examples
#' \dontrun{
#' # Create SpatialX object from basic count matrix and coordinates
#' counts <- matrix(rpois(1000, 5), nrow = 100, ncol = 10)
#' rownames(counts) <- paste0("Gene", 1:100)
#' colnames(counts) <- paste0("Spot_", 1:10)
#'
#' locations <- data.frame(x = runif(10), y = runif(10))
#'
#' spatialx_obj <- CreateSpatialXObject.default(
#' counts = counts,
#' location = locations,
#' project = "MyStudy",
#' species = "hsa"
#' )
#'
#' # Create with comprehensive spatial analysis data
#' cell_props <- matrix(runif(30), nrow = 3, ncol = 10)
#' rownames(cell_props) <- c("Neuron", "Astrocyte", "Microglia")
#' domains <- factor(rep(c("Cortex", "Hippocampus"), each = 5))
#'
#' spatialx_obj <- CreateSpatialXObject.default(
#' counts = counts,
#' location = locations,
#' cell.prop = cell_props,
#' domain.clust = domains,
#' species = "mmu",
#' min.cells = 3,
#' min.features = 100,
#' pct.cells = 0.01
#' )
#' }
#'
#' @seealso
#' \code{\link{CreateSpatialXObject.Seurat}},
#' \code{\link{CreateSpatialXObject.SpatialX}},
#' \code{\link{CreateSpatialXObject.Assay}}
#'
#' @rdname CreateSpatialXObject
#' @method CreateSpatialXObject default
#' @export
#'
#'
CreateSpatialXObject.default <- function(counts,
                                         location = NULL,
                                         cell.prop = NULL,
                                         domain.clust = NULL,
                                         project = 'SpatialX',
                                         assay = 'RNA',
                                         species = "hsa",
                                         names.field = 1,
                                         names.delim = '_',
                                         min.cells = 0,
                                         pct.cells = 0.005,
                                         min.features = 0,
                                         min.umi = 10,
                                         num.core = 1,
                                         row.names = NULL,
                                         version = "0.0.1", ...) {
	## add location information
	if (!is.null(x = location)) {
		if (!all(rownames(x = location) %in% colnames(x = counts))) {
			warning("Some cells in location not present in provided counts matrix")
		}## end fi
	}## end funcs
	
	## set idents
	idents <- factor(x = unlist(x = lapply(X = colnames(x = counts), 
	                                       FUN = ExtractField, field = names.field, delim = names.delim)))
	
	## if there are more than 100 idents, set all idents to ... name
	ident.levels <- length(x = unique(x = idents))
	if(ident.levels > 100 || ident.levels == 0 || ident.levels == length(x = idents)){
		idents <- rep.int(x = factor(x = project), times = ncol(x = counts))
	}## end fi
	names(x = idents) <- colnames(x = counts)
	
	## change counts and location names for integrative analysis of multiple 
	colnames(counts) <- paste0(colnames(counts),".", assay)

	
	## create assay data
	assay.data <- CreateAssayObject(counts = counts, 
									min.cells = min.cells,
									pct.cells = pct.cells,
									min.umi = min.umi,
									min.features = min.features, 
									row.names = row.names, 
									num.core = num.core)
	assay.data@ident <- idents
	
	## spatial location information proprecess
	if (!is.null(x = location)) {
	  rownames(location) <- paste0(rownames(location),".", assay)
		common.cells <- intersect(x = rownames(x = location), y = colnames(x = assay.data))
		location <- as.data.frame(location[common.cells, , drop = FALSE])
		## scale locations, might be necessary in practice
		location <- as.data.frame(lapply(location, as.numeric), row.names=common.cells)
		location <- as.data.frame(scale(location), row.names=common.cells)
		assay.data@location <- location
	}## end funcs
  
	## spatial cell proportion information proprecess
	if (!is.null(x = cell.prop)) {
	  rownames(cell.prop) <- paste0(rownames(cell.prop),".", assay)
	  common.cells <- intersect(x = rownames(x = cell.prop), y = colnames(x = assay.data))
	  cell.prop <- as.data.frame(cell.prop[common.cells, , drop = FALSE])
	  ## scale locations, might be necessary in practice
	  cell.prop <- as.data.frame(lapply(cell.prop, as.numeric), row.names=common.cells)
	  assay.data@cell.prop <- as.data.frame(cell.prop, row.names=common.cells)
	}## end funcs
	
	## spatial domain cluster information proprecess
	if (!is.null(x = domain.clust)) {
	  rownames(domain.clust) <- paste0(rownames(domain.clust),".", assay)
	  common.cells <- intersect(x = rownames(x = domain.clust), y = colnames(x = assay.data))
	  domain.clust <- as.data.frame(domain.clust[common.cells, , drop = FALSE])
	  ## scale locations, might be necessary in practice
	  domain.clust <- as.data.frame(lapply(domain.clust, as.numeric), row.names=common.cells)
	  assay.data@domain.clust <- as.data.frame(domain.clust, row.names=common.cells)
	}## end funcs
	
	object <- CreateSpatialXObject(counts = assay.data,
	                               project = project,
	                               assay = assay,
	                               names.field = names.field,
	                               names.delim = names.delim,
	                               num.core = num.core,
	                               location = location,...)
	
	## species for this study
	object@species <- species
	object@version <- as.character(version)
	object@num.core <- num.core
	return(object)
}## end funcs



#' Create a SpatialX object from Assay data
#'
#' @description
#' This function creates a SpatialX object from raw count data, enabling
#' spatial transcriptomics analysis with integrated spatial coordinates,
#' cell type proportions, and spatial domain information.
#'
#' @param counts The raw count data. Can be a matrix, data.frame, or Assay object
#' containing gene expression counts with features as rows and
#' cells/spots as columns
#' @param location Spatial coordinates data.frame or matrix with rows corresponding
#' to cells/spots and columns for spatial coordinates (x, y, and
#' optionally z). Required for spatial analysis
#' @param cell.prop Cell type proportion matrix for spatial deconvolution analysis,
#' with rows as cell types and columns as spatial spots
#' @param domain.clust Spatial domain labels or cluster assignments for each
#' cell/spot. Can be a vector or factor with length equal to
#' number of cells
#' @param project Name of the project for the SpatialX object (default: 'SpatialX')
#' @param assay Name of the primary assay for this project (default: 'RNA')
#' @param names.field Field index in cell names containing sample information
#' (default: 1)
#' @param names.delim Delimiter used in cell names to separate fields (default: '')
#' @param num.core Number of CPU cores to use for parallel processing (default: 1)
#' @param meta.data Additional metadata about each cell/spot. Should be a data.frame
#' with rows corresponding to cells and columns containing metadata
#' variables. If NULL, basic metadata (nFeature, nCount, orig.ident)
#' will be automatically generated
#' @param row.names Optional vector of feature names to be used when \code{counts}
#' is a \code{data.frame} or \code{data.frame}-derived object
#' without row names
#' @param version Version of SpatialX specification this object follows (default: "0.0.1")
#' @param ... Additional arguments passed to internal functions
#'
#' @return Returns a SpatialX object containing the count data, spatial coordinates,
#' and any provided cell type proportions, spatial domains, and metadata
#'
#' @details
#' This function serves as a foundational constructor for SpatialX objects from
#' raw assay data. It creates a comprehensive spatial data structure that
#' integrates:
#' \itemize{
#' \item Gene expression counts from various technologies (RNA-seq, spatial transcriptomics)
#' \item Spatial coordinate information for spatial context
#' \item Cell type deconvolution results for mixed spatial spots
#' \item Spatial domain classifications for tissue region identification
#' \item Comprehensive cell-level metadata for downstream analysis
#' }
#'
#' The function performs data validation, ensures proper dimension matching
#' between counts and spatial coordinates, and initializes the object with
#' appropriate slots for spatial analysis workflows.
#'
#' @examples
#' \dontrun{
#' # Create from count matrix and spatial coordinates
#' counts_matrix <- matrix(rpois(1000, 5), nrow = 100, ncol = 10)
#' rownames(counts_matrix) <- paste0("Gene", 1:100)
#' colnames(counts_matrix) <- paste0("Spot_", 1:10)
#'
#' spatial_coords <- data.frame(x = runif(10), y = runif(10))
#'
#' spatialx_obj <- CreateSpatialXObject.Assay(
#' counts = counts_matrix,
#' location = spatial_coords,
#' project = "MySpatialProject"
#' )
#'
#' # Create with cell type proportions and spatial domains
#' cell_proportions <- matrix(runif(50), nrow = 5, ncol = 10)
#' rownames(cell_proportions) <- c("Tcell", "Bcell", "Macrophage", "Neuron", "Astrocyte")
#' spatial_domains <- factor(rep(c("Domain1", "Domain2"), each = 5))
#'
#' spatialx_obj <- CreateSpatialXObject.Assay(
#' counts = counts_matrix,
#' location = spatial_coords,
#' cell.prop = cell_proportions,
#' domain.clust = spatial_domains,
#' assay = "SpatialRNA"
#' )
#' }
#'
#' @seealso
#' \code{\link{CreateSpatialXObject.Seurat}},
#' \code{\link{CreateSpatialXObject.SpatialX}},
#' \code{\link{AddMetaData}}
#'
#' @rdname CreateSpatialXObject
#' @method CreateSpatialXObject Assay
#' @export
#'
#'
CreateSpatialXObject.Assay <- function(counts,
                                    	location = NULL,
                                    	cell.prop = NULL,
                                    	domain.clust = NULL,
                                    	project = 'SpatialX',
                                    	assay = 'RNA',
                                    	names.field = 1,
                                    	names.delim = '_',
                                    	num.core = 1,
                                    	meta.data = NULL,
                                    	row.names = NULL,
                                    	version = "0.0.1", ...) {
                                      ## location
                                    	if (!is.null(x = location)) {
                                    		if (inherits(x = location, what = c('matrix', 'Matrix'))) {
                                    			location <- as.data.frame(x = location)
                                    		}## end fi
                                      
                                    		if (is.null(x = rownames(x = location))) {
                                    		  stop("Row names not set in location. Please ensure that rownames of location match column names of data matrix")
                                    		}## end fi
                                    		if (length(x = setdiff(x = rownames(x = location), y = colnames(x = counts)))) {
                                    		  warning("Some cells in location not present in provided counts matrix.")
                                    		  location <- location[intersect(x = rownames(x = location), y = colnames(x = counts)), , drop = FALSE]
                                    		}## end fi
                                    		if (is.data.frame(x = location)) {
                                    			new.location <- data.frame(row.names = colnames(x = counts))
                                    			for (ii in 1:ncol(x = location)) {
                                    				new.location[rownames(x = location), colnames(x = location)[ii]] <- location[, ii, drop = FALSE]
                                    			}## end for
                                    			location <- new.location
                                    		}## end fi
                                    	}## end fi
                                      
                                      ## cell proportion
                                      if (!is.null(x = cell.prop)) {
                                        if (inherits(x = cell.prop, what = c('matrix', 'Matrix'))) {
                                          cell.prop <- as.data.frame(x = cell.prop)
                                        }## end fi
                                        
                                        if (is.null(x = rownames(x = cell.prop))) {
                                          stop("Row names not set in cell.prop. Please ensure that rownames of cell.prop match column names of data matrix")
                                        }## end fi
                                        if (length(x = setdiff(x = rownames(x = cell.prop), y = colnames(x = counts)))) {
                                          warning("Some cells in cell.prop not present in provided counts matrix.")
                                          cell.prop <- cell.prop[intersect(x = rownames(x = cell.prop), y = colnames(x = counts)), , drop = FALSE]
                                        }## end fi
                                        if (is.data.frame(x = cell.prop)) {
                                          new.cell.prop <- data.frame(row.names = colnames(x = counts))
                                          for (ii in 1:ncol(x = cell.prop)) {
                                            new.cell.prop[rownames(x = cell.prop), colnames(x = cell.prop)[ii]] <- cell.prop[, ii, drop = FALSE]
                                          }## end for
                                          cell.prop <- new.cell.prop
                                        }## end fi
                                      }## end fi
                                      
                                      ## domain cluster
                                      if (!is.null(x = domain.clust)) {
                                        if (inherits(x = domain.clust, what = c('matrix', 'Matrix'))) {
                                          domain.clust <- as.data.frame(x = domain.clust)
                                        }## end fi
                                        
                                        if (is.null(x = rownames(x = domain.clust))) {
                                          stop("Row names not set in domain.clust. Please ensure that rownames of domain.clust match column names of data matrix")
                                        }## end fi
                                        if (length(x = setdiff(x = rownames(x = domain.clust), y = colnames(x = counts)))) {
                                          warning("Some cells in domain.clust not present in provided counts matrix.")
                                          domain.clust <- domain.clust[intersect(x = rownames(x = domain.clust), y = colnames(x = counts)), , drop = FALSE]
                                        }## end fi
                                        if (is.data.frame(x = domain.clust)) {
                                          new.domain.clust <- data.frame(row.names = colnames(x = counts))
                                          for (ii in 1:ncol(x = domain.clust)) {
                                            new.domain.clust[rownames(x = domain.clust), colnames(x = domain.clust)[ii]] <- domain.clust[, ii, drop = FALSE]
                                          }## end for
                                          domain.clust <- new.domain.clust
                                        }## end fi
                                      }## end fi
                                      
                                    	assay.list <- list(counts)
                                    	names(x = assay.list) <- assay
                                    	
                                    	
                                    	
                                    	## create new SpatialX object
                                    	object <- new(Class = 'SpatialX',
                                    		assays = assay.list,
                                    		active.assay = assay,
                                    		project.name = project)
                                    
                                    	### Calculate library size and number of expressed genes or cells
                                    	metrics <- CalQCMetrics(object = object)
                                    
                                    	if (!is.null(x = metrics)) {
                                    		colnames(x = metrics$cell_level) <- paste(colnames(x = metrics$cell_level), assay, sep = '_')
                                    		object <- SetAssayData(object, slot = "meta.data", new.data = as.data.frame(metrics$cell_level))
                                    		
                                    		colnames(x = metrics$feature_level) <- paste(colnames(x = metrics$feature_level), assay, sep = '_')
                                    		object <- SetAssayData(object, slot = "meta.features", new.data = as.data.frame(metrics$feature_level))
                                    	}## end fi
                                    	
                                    	## Add metadata
                                    	if (!is.null(x = location)) {
                                    		object <- SetAssayData(object, slot = "location", new.data = location)
                                    	}## end fi
                                    	if (!is.null(x = cell.prop)) {
                                    	  object <- SetAssayData(object, slot = "cell.prop", new.data = cell.prop)
                                    	}## end fi
                                    	if (!is.null(x = domain.clust)) {
                                    	  object <- SetAssayData(object, slot = "domain.clust", new.data = domain.clust)
                                    	}## end fi
                                    	return(object)
                                    }## end funcs



#' Add a new assay to an existing SpatialX object
#'
#' @description
#' This function adds a new assay (e.g., RNA, ATAC, Spatial) to an existing
#' SpatialX object, enabling multi-modal data integration while maintaining
#' spatial context and existing data structure.
#'
#' @param counts An existing SpatialX object to which the new assay will be added
#' @param counts.new A count matrix or data object containing the new assay data
#' to be added to the SpatialX object
#' @param project Project name for the updated SpatialX object (default: "SpatialX")
#' @param assay Name for the newly added assay (e.g., "RNA_new", "ATAC", "Spatial")
#' @param names.field Field index in cell names containing sample information (default: 1)
#' @param names.delim Delimiter used in cell names to separate fields (default: '')
#' @param location Optional spatial coordinates for the new assay data. If NULL,
#' uses existing spatial coordinates from the SpatialX object
#' @param min.cells Include features detected in at least this many cells. Features
#' with fewer detected cells will be filtered out (default: 0)
#' @param pct.cells Minimum percentage of cells in which a feature must be detected
#' to be included (default: 0.005)
#' @param min.umi Minimum UMI counts per cell. Cells with fewer UMIs will be filtered out (default: 10)
#' @param num.core Number of CPU cores to use for parallel processing (default: 1)
#' @param min.features Include cells where at least this many features are detected.
#' Cells with fewer features will be filtered out (default: 0)
#' @param row.names Optional vector of feature names to use when the new count data is a
#' \code{data.frame} or \code{data.frame}-derived object
#' @param version Version of SpatialX specification for the updated object (default: "0.0.1")
#' @param ... Additional arguments passed to other methods
#'
#' @return Returns an updated SpatialX object containing the original data along
#' with the newly added assay, properly integrated and validated
#'
#' @details
#' This method extends an existing SpatialX object by adding new assay data,
#' enabling multi-modal analysis while preserving spatial relationships and
#' existing data structures. The function performs:
#' \itemize{
#' \item Validation of compatibility between new assay data and existing object
#' \item Spatial coordinate alignment and verification
#' \item Quality control filtering on the new assay data
#' \item Integration of the new assay into the SpatialX object structure
#' \item Preservation of all existing assays and metadata
#' }
#'
#' The function ensures that cell barcodes between the existing object and new
#' assay data are properly matched, and applies the same rigorous quality control
#' standards to the new data as would be applied during initial object creation.
#'
#' @examples
#' \dontrun{
#' # Load an existing SpatialX object
#' data(existing_spatialx)
#'
#' # Create new RNA assay data
#' new_rna_counts <- matrix(rpois(1000, 1), nrow = 100)
#' rownames(new_rna_counts) <- paste0("Gene", 1:100)
#' colnames(new_rna_counts) <- colnames(existing_spatialx)
#'
#' # Add the new RNA assay to existing SpatialX object
#' updated_spatialx <- CreateSpatialXObject.SpatialX(
#' counts = existing_spatialx,
#' counts.new = new_rna_counts,
#' assay = "RNA_secondary",
#' min.cells = 5,
#' pct.cells = 0.01
#' )
#'
#' # Add ATAC assay data with custom spatial coordinates
#' new_atac_data <- matrix(sample(0:1, 500, replace = TRUE), nrow = 50)
#' custom_locations <- data.frame(x = runif(ncol(new_atac_data)),
#' y = runif(ncol(new_atac_data)))
#'
#' updated_spatialx <- CreateSpatialXObject.SpatialX(
#' counts = existing_spatialx,
#' counts.new = new_atac_data,
#' assay = "ATAC",
#' location = custom_locations
#' )
#' }
#'
#' @seealso
#' \code{\link{CreateSpatialXObject.Seurat}}, \code{\link{SpatialX-class}}
#'
#' @rdname CreateSpatialXObject
#' @method CreateSpatialXObject SpatialX
#' @export
#'
#'
CreateSpatialXObject.SpatialX <- function(counts,
                                          counts.new = NULL,
                                          project = "SpatialX",
                                          assay = 'RNA_new',
                                          names.field = 1,
                                          names.delim = '_',
                                          location = NULL,
                                          min.cells = 0,
                                          pct.cells = 0.005,
                                          min.umi = 10,
                                          num.core = 1,
                                          min.features = 0,
                                          row.names = NULL,
                                          version = "0.0.1", ...) {
  
	## adding a gene expression data based on the existing SpatialX object
	if(is.null(counts.new)){
		stop("Please provide 'counts.new' in this function!")
	}## end fi
  
  ## add location information
  if (!is.null(x = location)) {
    if (!all(rownames(x = location) %in% colnames(x = counts.new))) {
      warning("Some cells in location not present in provided counts matrix")
    }## end fi
  }## end funcs
  
  ## set idents
  idents <- factor(x = unlist(x = lapply(X = colnames(x = counts.new), FUN = ExtractField, field = names.field, delim = names.delim)))
  
  ## change count names if doing integrative analysis of multiple assays
  rownames(location) <- paste0(colnames(counts.new),".", assay)
  colnames(counts.new) <- paste0(colnames(counts.new),".", assay)
  
  ## create assay data
  assay.data <- CreateAssayObject(counts = counts.new, 
                                  min.cells = min.cells,
                                  pct.cells = pct.cells,
                                  min.umi = min.umi,
                                  min.features = min.features, 
                                  row.names = row.names, 
                                  num.core = num.core)
  assay.data@ident <- idents
  rm(counts.new);gc();
  
  ## spatial location information proprecess
  if (!is.null(x = location)) {
    common.cells <- intersect(x = rownames(x = location), y = colnames(x = assay.data))
    location <- location[common.cells, , drop = FALSE]
    ## scale locations, might be necessary in practice
    location <- as.data.frame(scale(location))
  }## end funcs
  
  
	## Create assay data
	slot(assay.data, name = "location") <- location
	
	## add a new assay
	counts@assays[[assay]] <- assay.data
	return(counts)
}## end funcs



#' Create a SpatialX object from a Seurat object
#'
#' @description
#' This function converts a Seurat object into a SpatialX object, enabling
#' spatial transcriptomics analysis with additional spatial context and
#' specialized data structures.
#'
#' @param counts A Seurat object containing single-cell or spatial transcriptomics data
#' @param project Project name for the SpatialX object (default: "SpatialX")
#' @param assay Name of the assay in Seurat object to use for conversion (default: "Spatial")
#' @param names.assay Name to assign to the assay in the resulting SpatialX object (default: 'SpatialRNA')
#' @param split.by Metadata column name in Seurat object that defines sample splits.
#' Useful when the Seurat object contains multiple samples that should
#' be processed separately
#' @param names.field Field index in cell names containing sample information (default: 1)
#' @param names.delim Delimiter used in cell names to separate fields (default: '')
#' @param location Spatial coordinates data.frame or matrix with rows corresponding to
#' cells and columns for spatial coordinates (x, y). If NULL, attempts
#' to extract from Seurat object
#' @param min.cells Include features detected in at least this many cells. Features
#' with fewer detected cells will be filtered out (default: 0)
#' @param pct.cells Minimum percentage of cells in which a feature must be detected
#' to be included (default: 0.005)
#' @param min.umi Minimum UMI counts per cell. Cells with fewer UMIs will be filtered out (default: 10)
#' @param num.core Number of CPU cores to use for parallel processing (default: 1)
#' @param min.features Include cells where at least this many features are detected.
#' Cells with fewer features will be filtered out (default: 0)
#' @param row.names Optional vector of feature names to use when \code{counts} is a
#' \code{data.frame} or \code{data.frame}-derived object
#' @param version Version of SpatialX specification this object follows (default: "0.0.1")
#' @param ... Additional arguments passed to other methods
#'
#' @return Returns a SpatialX object containing the converted data with spatial
#' information and assay data structured for spatial transcriptomics analysis
#'
#' @details
#' This function provides a bridge between the Seurat ecosystem and SpatialX,
#' allowing users to leverage existing Seurat objects for specialized spatial
#' analysis. The conversion process includes:
#' \itemize{
#' \item Extraction and transformation of count matrices
#' \item Integration of spatial coordinate information
#' \item Handling of multiple samples through splitting parameters
#' \item Quality control filtering based on cell and feature metrics
#' \item Preservation of essential metadata and assay information
#' }
#'
#' The function performs validation to ensure spatial coordinates align properly
#' with cell barcodes and applies quality control filters to remove low-quality
#' cells and features.
#'
#' @examples
#' \dontrun{
#' # Load a Seurat object with spatial data
#' data(seurat_object_with_spatial)
#'
#' # Convert to SpatialX object with default parameters
#' spatialx_obj <- CreateSpatialXObject.Seurat(
#' counts = seurat_object_with_spatial,
#' project = "MySpatialProject",
#' assay = "Spatial",
#' location = GetTissueCoordinates(seurat_object_with_spatial)
#' )
#'
#' # Convert with sample splitting and filtering
#' spatialx_obj <- CreateSpatialXObject.Seurat(
#' counts = multi_sample_seurat,
#' split.by = "sample_id",
#' min.cells = 10,
#' min.features = 200,
#' pct.cells = 0.01
#' )
#' }
#'
#' @seealso
#' \code{\link{CreateSpatialXObject}}
#'
#' @rdname CreateSpatialXObject
#' @method CreateSpatialXObject Seurat
#' @export
#'
CreateSpatialXObject.Seurat <- function(counts,
                                        project = "SpatialX",
                                        assay = "Spatial",
                                        names.assay = 'SpatialRNA',
                                        split.by = NULL,
                                        names.field = 1,
                                        names.delim = '_',
                                        location = NULL,
                                        min.cells = 0,
                                        pct.cells = 0.005,
                                        min.umi = 10,
                                        num.core = 1,
                                        min.features = 0,
                                        row.names = NULL,
                                        version = "0.0.1",  ...) {
  ## create the list for assays
  assay.list <- list()
  if(is.null(split.by)){## only contain one sample
    location <- counts@images[[1]]@coordinates[,c(4,5)]
    assay.data <- CreateAssayObjectEach(counts = Seurat::GetAssayData(counts, slot="counts"), 
                                   location = as.data.frame(location), 
                                   meta.data = counts@meta.data,
                                   min.cells = min.cells,
                                   pct.cells = pct.cells,
                                   min.umi = min.umi,
                                   num.core = num.core,
                                   min.features = min.features,
                                   row.names = row.names)
    ## add a new assay
    assay.data <- SetAssayData(assay.data, slot="ident", new.data=as.factor(colnames(counts))) 
    assay.list[[1]] <- assay.data
    names(assay.list) <- names(counts@images)
    
  }else{## contain multiple assay
    if(split.by %in% colnames(counts[[]])){
      meta.data.all <- counts[[split.by]]
      assays <- names(counts@images)
      for(igroup in seq_len(length(assays))){
        ## add a new assay
        location <- counts@images[[igroup]]@coordinates[,c(4,5)]
        sub_assay <- subset(counts, cells = rownames(location))
        assay.data <- CreateAssayObjectEach(counts = Seurat::GetAssayData(sub_assay, slot="counts"), 
                                       location = as.data.frame(location), 
                                       meta.data = sub_assay@meta.data,
                                       min.cells = min.cells,
                                       pct.cells = pct.cells,
                                       min.umi = min.umi,
                                       num.core = num.core,
                                       min.features = min.features,
                                       row.names = row.names)
        assay.data <- SetAssayData(assay.data, slot="ident", new.data=as.factor(rownames(location))) 
        assay.list[[igroup]] <- assay.data
      }## end for
      names(assay.list) <- assays
      
    }else{
      stop("The 'split.by' is not in meta.data of counts!")
    }
  }## end fi
  
  
  ## create new SpatialX object
  object <- new(Class = 'SpatialX',
                assays = assay.list,
                active.assay = names(assay.list)[1],
                project.name = project)
  ## return the project
  return(object)
}## end funcs



####
#' @rdname CreateSpatialXObject
#' @export CreateSpatialXObject
#' 
#'
CreateSpatialXObject <- function(counts, ...) {
  UseMethod(generic = 'CreateSpatialXObject', object = counts)
}## end funcs


#' Check the version of objects
#'
#' @description
#' These functions retrieve version information from various objects, allowing
#' users to track object specifications and ensure compatibility between
#' different components of the analysis pipeline.
#'
#' @param object An object from which to retrieve version information.
#' Currently supports SpatialX objects
#' @param ... Additional arguments passed to methods
#'
#' @return Returns the version information stored in the object. For SpatialX
#' objects, returns the version string from the object's version slot.
#'
#' @details
#' The Version generic function provides a unified interface for accessing
#' version information across different object types in the package. This is
#' particularly useful for:
#' \itemize{
#' \item Ensuring compatibility between different versions of objects
#' \item Reproducibility of analyses
#' \item Debugging version-related issues
#' \item Tracking object specifications across package updates
#' }
#'
#' @section Available methods:
#' \describe{
#' \item{\code{Version.SpatialX}}{Retrieve version from SpatialX objects}
#' }
#'
#' @examples
#' \dontrun{
#' # Check version of a SpatialX object
#' spatialx_version <- Version(spatialx_object)
#' print(spatialx_version)
#'
#' # Use version information for compatibility checks
#' if (Version(object) < "2.0.0") {
#' warning("This object was created with an older version of the package")
#' }
#' }
#'
#' @seealso
#' \code{\link{SpatialX-class}}
#'
#' @rdname Version
#' @concept data-access
#' @export
#'
Version.SpatialX <- function(object, ...) {
  return(slot(object = object, name = 'version'))
}## end func

#' @rdname Version
#' @export Version
#' 
Version <- function(object, ...) {
  UseMethod(generic = "Version", object = object)
}## end func


###########
#' Merge a new assay to an existing SpatialX object
#'
#' @description
#' This function merges a new assay dataset into an existing SpatialX object,
#' allowing integration of additional molecular measurements while preserving
#' existing data structure and metadata.
#'
#' @param object A SpatialX object to which the new assay will be added
#' @param assay.data The new assay data to be merged. Should be compatible with
#' the spatial coordinates and existing data structure
#' @param assay.name Character string specifying the name for the new assay.
#' Default is 'SpatialRNA_new'
#' @param ... Additional arguments passed to methods
#'
#' @return Returns a SpatialX object with the new assay data integrated into
#' the existing object structure
#'
#' @details
#' The function validates the compatibility of the new assay data with the
#' existing SpatialX object before merging. This includes checking spatial
#' coordinate alignment, feature names, and data integrity. The merged object
#' maintains all original assays and metadata while adding the new dataset.
#'
#' @examples
#' \dontrun{
#' # Load example SpatialX object
#' data(example_spatialx)
#'
#' # Create new assay data
#' new_assay <- matrix(rnorm(1000), nrow = 100)
#' rownames(new_assay) <- paste0("Gene_", 1:100)
#' colnames(new_assay) <- colnames(example_spatialx)
#'
#' # Merge new assay
#' merged_obj <- MergeSpatialXObject(example_spatialx,
#' assay.data = new_assay,
#' assay.name = "CustomAssay")
#' }
#'
#' @seealso
#' \code{\link{SpatialX-class}}
#'
#' @rdname MergeSpatialXObject
#' @method MergeSpatialXObject SpatialX
#' @export
#'
MergeSpatialXObject.SpatialX <- function(object, 
                                         assay.data = NULL, 
                                         assay.name = 'SpatialRNA_new', ...) {
  
  ## adding an assay data based on the existing SpatialX object
  if(is.null(assay.data)){
    stop("MergeSpatialXObject:: Please provide 'assay.data' in this function!")
  }## end fi
  
  if(class(assay.data) == "Assay"){
    object@assays <- c(object@assays, assay.data)
    
  }else if(class(assay.data) == "list"){
    exist.assay.name <- names(object)
    new.assay.name <- names(assay.data)
    if(is.null(new.assay.name)){
      names(assay.data) <- paste0(assay.name, 1:length(assay.data))
      new.assay.name <- paste0(assay.name, 1:length(assay.data))
    }## end fi
    
    for(iassay in new.assay.name){
      if(iassay %in% exist.assay.name){
        object@assays[[iassay]] <- assay.data[[iassay]]
      }else{
        tmp_assay <- list(assay.data[[iassay]])
        names(tmp_assay) <- iassay
        object@assays <- c(object@assays, tmp_assay)
      }## end fi
    }## end for
    
  }else{
    stop("MergeSpatialXObject:: The class of 'assay.data' could be either 'Assay' or 'list'. ")
  }## end fi
  
  return(object)
}## end funcs


#' Merge a new assay to an existing Assay object
#'
#' @description
#' This function merges a new assay dataset into an existing Assay object,
#' enabling the integration of additional molecular measurements while
#' maintaining data consistency and structure.
#'
#' @param object An Assay object to which the new assay will be added
#' @param assay.data The new assay data to be merged. Should be compatible with
#' the existing Assay object in terms of dimensions and
#' feature names
#' @param assay.name Character string specifying the name for the new assay.
#' Default is 'SpatialRNA_new'
#' @param ... Additional arguments passed to methods
#'
#' @return Returns an Assay object with the new assay data integrated,
#' preserving the original data structure and metadata
#'
#' @details
#' This method validates the compatibility of the new assay data with the
#' existing Assay object, including checking feature names, cell barcodes,
#' and data dimensions. The function ensures seamless integration of additional
#' assay data while maintaining data integrity and relationships between
#' different assay layers.
#'
#' @examples
#' \dontrun{
#' # Load example Assay object
#' data(example_assay)
#'
#' # Create new assay data with compatible dimensions
#' new_assay_data <- matrix(rnorm(500), nrow = 50)
#' rownames(new_assay_data) <- paste0("Feature_", 1:50)
#' colnames(new_assay_data) <- colnames(example_assay)
#'
#' # Merge new assay into existing Assay object
#' merged_assay <- MergeSpatialXObject(example_assay,
#' assay.data = new_assay_data,
#' assay.name = "NewMeasurement")
#' }
#'
#' @seealso
#' \code{\link{Assay-class}}, \code{\link{MergeSpatialXObject.SpatialX}}
#'
#' @rdname MergeSpatialXObject
#' @method MergeSpatialXObject Assay
#' @export
#'
MergeSpatialXObject.Assay <- function(object, 
                                      assay.data = NULL, 
                                      assay.name = 'SpatialRNA_new', ...) {
  
  ## adding an assay data based on the existing Assay object
  if(is.null(assay.data)){
    stop("MergeSpatialXObject:: Please provide 'assay.data' in this function!")
  }## end fi
  
  if(class(assay.data) == "Assay"){
    object <- c(object, assay.data)
    
  }else if(class(assay.data) == "list"){
    exist.assay.name <- names(object)
    new.assay.name <- names(assay.data)
    if(is.null(new.assay.name)){
      names(assay.data) <- paste0(assay.name, 1:length(assay.data))
      new.assay.name <- paste0(assay.name, 1:length(assay.data))
    }## end fi
    
    for(iassay in new.assay.name){
      if(iassay %in% exist.assay.name){
        object <- assay.data[[iassay]]
      }else{
        object <- c(object, assay.data[[iassay]])
      }## end fi
    }## end for
    
  }else{
    stop("MergeSpatialXObject:: The class of 'assay.data' could be either 'Assay' or 'list'. ")
  }## end fi
  
  return(object)
}## end funcs


#' @rdname MergeSpatialXObject
#' @export MergeSpatialXObject
#' 
MergeSpatialXObject <- function(object, ...) {
  UseMethod(generic = "MergeSpatialXObject", object = object)
}## end func

##################################################

#' Extracts matrix data from the specified slot and calculates column means.
#'
#' @param x A SpatialX object
#' @param na.rm Logical, whether to remove NA values during calculation (default: FALSE)
#' @param dims Integer, specifying the dimensions for calculation (default: 1)
#' @param ... Additional arguments passed to the underlying Matrix::colMeans function
#' @param slot Character, specifying which data slot to extract data from (default: 'counts')
#'
#' @return Returns a numeric vector containing the mean of each column
#'
#' @examples
#' \dontrun{
#' # Assuming sx is a SpatialX object
#' col_means <- colMeans(sx, slot = "counts")
#' }
#'
#' @export
#' @rdname SpatialX-class
#' 
setMethod(f = "colMeans",
  signature = c(x = "SpatialX"),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::colMeans(x = GetAssayData(object = x, slot = slot), 
                    na.rm = na.rm, 
                    dims = dims,
      ...))
  })


#' Extracts matrix data from the specified slot and calculates column sums.
#'
#' @param x A SpatialX object
#' @param na.rm Logical, whether to remove NA values during calculation (default: FALSE)
#' @param dims Integer, specifying the dimensions for calculation (default: 1)
#' @param ... Additional arguments passed to the underlying Matrix::colSums function
#' @param slot Character, specifying which data slot to extract data from (default: 'counts')
#'
#' @return Returns a numeric vector containing the sum of each column
#'
#' @examples
#' \dontrun{
#' # Assuming sx is a SpatialX object
#' col_sums <- colSums(sx, slot = "counts")
#' }
#'
#' @export
#' @rdname SpatialX-class
#' 
setMethod(f = 'colSums',
  signature = c('x' = 'SpatialX'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::colSums(x = GetAssayData(object = x, slot = slot), na.rm = na.rm, dims = dims,
      ...))
  })

#' Extracts matrix data from the specified slot and calculates row means.
#'
#' @param x A SpatialX object
#' @param na.rm Logical, whether to remove NA values during calculation (default: FALSE)
#' @param dims Integer, specifying the dimensions for calculation (default: 1)
#' @param ... Additional arguments passed to the underlying Matrix::rowMeans function
#' @param slot Character, specifying which data slot to extract data from (default: 'counts')
#'
#' @return Returns a numeric vector containing the mean of each row
#'
#' @examples
#' \dontrun{
#' # Assuming sx is a SpatialX object
#' row_means <- rowMeans(sx, slot = "counts")
#' }
#'
#' @export
#' @rdname SpatialX-class
#'
setMethod(f = 'rowMeans',
  signature = c('x' = 'SpatialX'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::rowMeans(x = GetAssayData(object = x, slot = slot),na.rm = na.rm,dims = dims,
      ...))
  })

#' 
#' Extracts matrix data from the specified slot and calculates row sums.
#'
#' @param x A SpatialX object
#' @param na.rm Logical, whether to remove NA values during calculation (default: FALSE)
#' @param dims Integer, specifying the dimensions for calculation (default: 1)
#' @param ... Additional arguments passed to the underlying Matrix::rowSums function
#' @param slot Character, specifying which data slot to extract data from (default: 'counts')
#'
#' @return Returns a numeric vector containing the sum of each row
#'
#' @examples
#' \dontrun{
#' # Assuming sx is a SpatialX object
#' row_sums <- rowSums(sx, slot = "counts")
#' }
#'
#' @export
#' @rdname SpatialX-class
#'
setMethod(f = 'rowSums',
  signature = c('x' = 'SpatialX'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'counts') {
    return(Matrix::rowSums(x = GetAssayData(object = x, slot = slot),na.rm = na.rm,dims = dims,
      ...))
  })

#' Get assay names from SpatialX objects
#' Returns the names of all assays in the SpatialX object.
#'
#' @param x A SpatialX object
#'
#' @return Returns a character vector containing the names of all assays
#'
#' @examples
#' \dontrun{
#' # Assuming sx is a SpatialX object
#' assay_names <- names(sx)
#' }
#'
#' @export
#' @rdname SpatialX-class
#'
setMethod(f = 'names',
  signature = c('x' = 'SpatialX'),
  definition = function(x) {
    return(names(slot(object = x, name = "assays")))
  })


#' Display summary information for SpatialX objects
#'
#' Displays the structure and content summary of a SpatialX object in a user-friendly format.
#'
#' @param object A SpatialX object
#'
#' @return No return value, outputs object information to the console
#'
#' @examples
#' \dontrun{
#' # Assuming sx is a SpatialX object
#' show(sx)
#' # Or simply type the object name
#' sx
#' }
#'
#' @export
#' @rdname SpatialX-class
#' 
setMethod(f = "show",
  signature = "SpatialX",
  definition = function(object) {
	assays <- names(slot(object = object, name = 'assays'))
    nfeatures <- sum(vapply(X = assays,
      FUN = function(x) {
        return(nrow(x = object[[x]]))
      }, FUN.VALUE = integer(length = 1L)  ))
    
    num.assays <- length(x = assays)
    
    cat("## An object of class", class(x = object), 'with', num.assays,
      ifelse(test = num.assays == 1, yes = 'assay', no = 'assays'), "\n")
    for(iassay in 1:num.assays){
      cat("### Assay ", iassay, ' (',assays[iassay],') : ', 
          dim(x = object[[assays[iassay]]])[1],' features; ', 
          dim(x = object[[assays[iassay]]])[2] , ' samples. \n')
    }## end for
    cat("## Active assay is: ",  DefaultAssay(object = object), "\n")
    cat("## Package version is: ",  Version(object) ,"\n")
    cat('\n')
  })


#' Display summary information for Assay objects
#'
#' Displays the structure and content summary of an Assay object in a user-friendly format.
#'
#' @param object An Assay object
#'
#' @return No return value, outputs object information to the console
#'
#' @examples
#' \dontrun{
#' # Assuming assay is an Assay object
#' show(assay)
#' # Or simply type the object name
#' assay
#' }
#'
#' @export
#' @rdname Assay-class
#'
setMethod(f = "show",
          signature = "Assay",
          definition = function(object) {
            cat("## An object of class: ", class(x = object), "\n")
            cat("### Assay dimension is: ",
                  dim(x = slot(object = object, name = "counts"))[1],' features; ', 
                  dim(x = slot(object = object, name = "counts"))[2] , ' samples. \n')
            cat('\n')
          })



#' Add Metadata to Spatial Transcriptomics Object
#'
#' This function adds metadata to SpatialX objects at both cell/spot level
#' and feature/gene level. Metadata can include cell types, experimental
#' conditions, sample information, or any other annotations.
#'
#' @param object A SpatialX object or other supported object type
#' @param meta.data Metadata to add. Can be:
#' \itemize{
#'   \item{A named vector for cell/spot annotations}
#'   \item{A data.frame with row names matching cell/spot names}
#'   \item{A list of metadata elements}
#' }
#' @param col.name Column name for the metadata when adding to object.
#' If NULL, uses the name of the metadata object.
#' @param ... Additional arguments passed to methods
#'
#' @return Returns the input object with metadata added to the appropriate
#' slot. For cell-level metadata, adds to the \code{colData} slot. For
#' feature-level metadata, adds to the \code{rowData} slot.
#'
#' @examples
#' \dontrun{
#' # Add cell type annotations
#' cell_types <- c("spot1" = "Neuron", "spot2" = "Astrocyte", "spot3" = "Neuron")
#' object <- AddMetaData(object, metadata = cell_types, col.name = "cell_type")
#'
#' # Add multiple metadata columns from a data.frame
#' sample_info <- data.frame(
#'   batch = rep(c("A", "B"), each = ncol(object)/2),
#'   condition = rep(c("Control", "Treatment"), ncol(object)/2)
#' )
#' rownames(sample_info) <- colnames(object)
#' object <- AddMetaData(object, metadata = sample_info)
#'
#' # Add gene annotations
#' gene_info <- data.frame(
#'   chromosome = c("chr1", "chr2", "chr1"),
#'   start_position = c(1000, 2000, 3000)
#' )
#' rownames(gene_info) <- rownames(object)[1:3]
#' object <- AddMetaData(object, metadata = gene_info, col.name = "gene_annotations")
#' }
#'
#' @rdname AddMetaData
#' @concept data-manipulation
#' @export
#' 
AddMetaData <- function(object, ...) {
  UseMethod(generic = 'AddMetaData', object = object)
}## end func


#' @rdname AddMetaData
#' @export
#' 
AddMetaData.Assay <- function(object, meta.data, col.name = NULL, ...) {
  
  if (is.null(x = col.name) && is.atomic(x = meta.data)) {
    stop("'col.name' must be provided for atomic metadata types (eg. vectors)")
  }## end fi
  
  ## to be data frame
  if (inherits(x = meta.data, what = c('matrix', 'Matrix'))) {
    meta.data <- as.data.frame(x = meta.data)
  }## end fi
  
  col.name <- col.name %||% names(x = meta.data) %||% colnames(x = meta.data)
  if (is.null(x = col.name)) {
    stop("No meta.data name provided and could not infer it from meta.data object")
  }## end fi
  
  ## original meta data
  old_metadata <- slot(object, name="meta.data")
  ##old_metadata[[col.name]] <- metadata
  
  ## update meta data
  if(rlang::is_empty(old_metadata)){
    object@meta.data <- meta.data
  }else if(identical(rownames(old_metadata), rownames(meta.data))){
    object@meta.data <- data.frame(old_metadata, col.name=meta.data)
  }else{
    stop("AddMetaData:: The rownames of meta.data is not match the original rownames of meta.data!")
  }## end fi
  
  
  return(object)
}## end funcs


#' Calculate quality control metrics for objects
#'
#' These functions calculate comprehensive quality control metrics for SpatialX
#' and Assay objects, providing both cell-level and feature-level statistics
#' essential for data quality assessment and filtering.
#'
#' @param object A SpatialX or Assay object for which to calculate QC metrics
#' @param assay Name of the assay to use for QC calculation (for SpatialX objects).
#'              If NULL, uses the default assay
#' @param ... Additional arguments passed to methods
#'
#' @return Returns a list containing two data.frames:
#' \itemize{
#'   \item \code{cell_level}: Cell-level QC metrics including:
#'     \itemize{
#'       \item \code{lib.size}: Total counts (library size) per cell
#'       \item \code{expr.feature}: Number of features expressed per cell
#'       \item \code{pct.dropout}: Percentage of features not expressed per cell
#'     }
#'   \item \code{feature_level}: Feature-level QC metrics including:
#'     \itemize{
#'       \item \code{expr.counts}: Total counts per feature
#'       \item \code{expr.cell}: Number of cells expressing the feature
#'       \item \code{pct.dropout}: Percentage of cells not expressing the feature
#'       \item \code{mean}: Mean expression level of the feature
#'       \item \code{var}: Variance of expression for the feature
#'     }
#' }
#'
#' @details
#' The CalQCMetrics functions provide essential quality control statistics
#' that are crucial for:
#' \itemize{
#'   \item Identifying low-quality cells with few counts or features
#'   \item Detecting poorly detected features with low expression
#'   \item Informing filtering thresholds for downstream analysis
#'   \item Assessing overall data quality and technical variation
#' }
#'
#' For SpatialX objects, the function delegates to the specified assay's method.
#' The calculations are performed on the raw count data to accurately reflect
#' data quality without normalization effects.
#'
#' @examples
#' \dontrun{
#' # Calculate QC metrics for a SpatialX object
#' qc_results <- CalQCMetrics(spatialx_obj)
#' 
#' # Access cell-level metrics
#' cell_metrics <- qc_results$cell_level
#' head(cell_metrics)
#' 
#' # Access feature-level metrics  
#' feature_metrics <- qc_results$feature_level
#' head(feature_metrics)
#' 
#' # Calculate QC for specific assay
#' atac_qc <- CalQCMetrics(spatialx_obj, assay = "ATAC")
#' 
#' # Calculate QC for Assay object directly
#' assay_qc <- CalQCMetrics(assay_obj)
#' 
#' # Use QC metrics for filtering decisions
#' low_quality_cells <- which(cell_metrics$lib.size < 1000)
#' low_quality_features <- which(feature_metrics$expr.cell < 3)
#' }
#'
#' @seealso
#' \code{\link{SpatialX-class}}, \code{\link{Assay-class}}
#'
#' @rdname CalQCMetrics
#' @export
#' 
CalQCMetrics <- function(object, ...) {
  UseMethod(generic = "CalQCMetrics", object = object)
}## end func

#' Calculate qc metrics from SpatialX object
#' 
#' @rdname CalQCMetrics
#' @method CalQCMetrics SpatialX
#' @export
#' 
CalQCMetrics.SpatialX <- function(object, assay = NULL, ...) {
  ## extract the active assay, RNA or ATAC or Spatial
  assay <- assay %||% DefaultAssay(object = object)
  ## Assay object
  assay.data <- GetAssay(object = object, assay = assay)
  meta.data <- CalQCMetrics(assay.data)
  
  return(meta.data)
}## end func

#' Calculate qc metrics from Assay object
#' @rdname CalQCMetrics
#' @method CalQCMetrics Assay
#' @export
#'
CalQCMetrics.Assay <- function(object, ...) {
  if (IsMatrixEmpty(x = GetAssayData(object = object, slot = "counts"))) {
    return(NULL)
  }## end fi
  return(list(cell_level = data.frame(lib.size = Matrix::colSums(GetAssayData(object = object, slot = "counts")),
                                      expr.feature = Matrix::colSums(GetAssayData(object = object, slot = "counts") > 0), 
                                      pct.dropout = 100*(1 - Matrix::colSums(GetAssayData(object = object, slot = "counts") > 0)/nrow(object))), 
              feature_level = data.frame(expr.counts = Matrix::rowSums(GetAssayData(object = object, slot = "counts")), 
                                         expr.cell = Matrix::rowSums(GetAssayData(object = object, slot = "counts") > 0),
                                         pct.dropout = 100*(1 - Matrix::rowSums(GetAssayData(object = object, slot = "counts") > 0)/ncol(object)),
                                         mean = Matrix::rowMeans(GetAssayData(object = object, slot = "counts")),
                                         var = matrixStats::rowVars(as.matrix(GetAssayData(object = object, slot = "counts"))) )))
}## end func


#' Get and set default assay
#'
#' These functions get and set the default (active) assay for SpatialX objects.
#' The default assay determines which assay is used by default in analysis and
#' visualization functions.
#'
#' @param object A SpatialX object
#' @param value Name of the assay to set as default
#' @param ... Additional arguments passed to methods
#'
#' @return \code{DefaultAssay}: Returns the name of the current default assay
#'
#' @return \code{DefaultAssay<-}: Returns the SpatialX object with updated default assay
#'
#' @details
#' The default assay is used by many functions in the package when no specific
#' assay is provided. This allows users to seamlessly work with multiple assays
#' while focusing analysis on a particular data modality.
#'
#' @examples
#' \dontrun{
#' # Get the current default assay
#' current_assay <- DefaultAssay(spatialx_obj)
#' print(current_assay)
#'
#' # Set a new default assay
#' DefaultAssay(spatialx_obj) <- "ATAC"
#'
#' # Verify the change
#' DefaultAssay(spatialx_obj)  # Returns "ATAC"
#'
#'
#' # Switch between assays for different analyses
#' DefaultAssay(spatialx_obj) <- "RNA"
#' variable_genes <- FindVariableFeatures(spatialx_obj)
#'
#' DefaultAssay(spatialx_obj) <- "Spatial"
#' spatial_genes <- FindSpatialGenes(spatialx_obj)
#' }
#'
#'
#' @rdname DefaultAssay
#' @export
DefaultAssay <- function(object, ...) {
  UseMethod(generic = 'DefaultAssay', object = object)
}


#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay SpatialX
#'
DefaultAssay.SpatialX <- function(object, ...) {
	return(slot(object = object, name = 'active.assay'))
}## end func


#' @rdname DefaultAssay
#' @export
#'
"DefaultAssay<-" <- function(object, ..., value) {
  UseMethod(generic = "DefaultAssay<-", object = object)
}## end funcs

#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay SpatialX
#'
#'
DefaultAssay.SpatialX <- function(object, ...) {
  default <- slot(object = object, name = 'active.assay')
  if (!length(x = default)) {
    default <- NULL
  }
  return(default)
}

#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay<- SpatialX
#' 
"DefaultAssay<-.SpatialX" <- function(object, ..., value) {
  
  if (!value %in% names(x = slot(object = object, name = 'assays'))) {
    stop("Cannot find assay: ", value)
  }
	slot(object = object, name = 'active.assay') <- value
	return(object)
}## end func


#' Get data from Assay objects
#'
#' These functions extract data from various slots of Assay and SpatialX objects,
#' providing flexible access to count matrices, normalized data, spatial coordinates,
#' metadata, and analysis results.
#'
#' @param object An Assay or SpatialX object from which to extract data
#' @param slot Specific assay data slot to access. For Assay objects, can be one of:
#'   \itemize{
#'     \item \code{counts}: Raw count data
#'     \item \code{data}: Normalized expression data
#'     \item \code{scale.data}: Scaled expression data
#'     \item \code{meta.data}: Cell-level metadata
#'     \item \code{cell.prop}: Cell type proportion matrix
#'     \item \code{domain.clust}: Spatial domain assignments
#'     \item \code{meta.features}: Feature-level metadata
#'     \item \code{images}: Associated image data
#'     \item \code{ident}: Cell identity labels
#'     \item \code{de}: Differential expression results
#'     \item \code{sv.genes}: Spatially variable genes
#'     \item \code{dr}: Dimensionality reduction results
#'     \item \code{svg}: Overall spatially variable genes
#'     \item \code{csvg}: Cell-type specific variable genes
#'     \item \code{dsvg}: Domain-specific variable genes
#'     \item \code{isvg}: Integrative spatially variable genes
#'     \item \code{res}: Miscellaneous results
#'     \item \code{de.truth}: Ground truth DE genes (simulations)
#'     \item \code{location}: Spatial coordinates
#'   }
#' @param assay Specific assay to get data from (for SpatialX objects). Defaults to
#'   the \link{DefaultAssay}
#' @param ... Additional arguments passed to methods
#'
#' @return Returns the data stored in the specified slot. The return type varies
#'   by slot, including matrices, data.frames, lists, or vectors.
#'
#' @details
#' The GetAssayData functions provide unified access to the diverse data types
#' stored in Assay and SpatialX objects. Key features:
#' \itemize{
#'   \item Consistent interface for accessing different data modalities
#'   \item Automatic handling of default assays in SpatialX objects
#'   \item Validation of slot names and assay existence
#'   \item Flexible extraction of analysis results and metadata
#' }
#'
#' For SpatialX objects, the function first retrieves the specified assay, then
#' extracts the requested slot from that assay. This allows seamless access to
#' assay-specific data without manual assay selection.
#'
#' @examples
#' \dontrun{
#' # Get data from an Assay object
#' assay_obj <- pbmc_small[["RNA"]]
#' 
#' # Access different data slots
#' counts_data <- GetAssayData(assay_obj, slot = "counts")
#' normalized_data <- GetAssayData(assay_obj, slot = "data")
#' spatial_coords <- GetAssayData(assay_obj, slot = "location")
#' cell_metadata <- GetAssayData(assay_obj, slot = "meta.data")
#' 
#' # Get data from a SpatialX object
#' # Access default assay data
#' default_data <- GetAssayData(spatialx_obj, slot = "data")
#' 
#' # Access specific assay data
#' rna_data <- GetAssayData(spatialx_obj, slot = "counts", assay = "RNA")
#' atac_data <- GetAssayData(spatialx_obj, slot = "counts", assay = "ATAC")
#' 
#' # Access analysis results
#' de_results <- GetAssayData(spatialx_obj, slot = "de")
#' svg_results <- GetAssayData(spatialx_obj, slot = "svg")
#' dimred_results <- GetAssayData(spatialx_obj, slot = "dr")
#' 
#' # Access spatial information
#' coordinates <- GetAssayData(spatialx_obj, slot = "location")
#' cell_proportions <- GetAssayData(spatialx_obj, slot = "cell.prop")
#' spatial_domains <- GetAssayData(spatialx_obj, slot = "domain.clust")
#' }
#'
#' @seealso
#' \code{\link{Assay-class}}, \code{\link{SpatialX-class}}, \code{\link{DefaultAssay}}
#'
#' @name AssayData
#' @rdname AssayData
#' @export
GetAssayData <- function(object, slot, ...) {
  UseMethod(generic = 'GetAssayData', object = object)
}

#' @rdname AssayData
#' @export
#' @method GetAssayData Assay
#' 
GetAssayData.Assay <- function(
  object,
  slot = c('data', 
	'scale.data', 
	'counts',
	'meta.data',
	'cell.prop',
	'domain.clust',
	'meta.features',
	'images',
	'ident',
	'de',
	'sv.genes',
	'dr',
	'svg',
	'csvg',
	'dsvg',
	'isvg',
	'res',
	'de.truth',
	'location'), ...) {
	slot <- slot[1]
	slot <- match.arg(arg = slot)
	return(slot(object = object, name = slot))
}## end func


#' @rdname AssayData
#' @export
#' @method GetAssayData SpatialX
#'
GetAssayData.SpatialX <- function(object, slot = 'data', assay = NULL, ...) {
	assay <- assay %||% DefaultAssay(object = object)
	if (!assay %in% names(object@assays)) {
		stop("'", assay, "' is not an assay", call. = FALSE)
	}## end fi
	return(GetAssayData(object = object@assays[[assay]], slot = slot))
}## end funcs

#' Set data in Assay objects
#'
#' These functions set data in various slots of Assay and SpatialX objects,
#' allowing modification of count matrices, normalized data, spatial coordinates,
#' metadata, and analysis results.
#'
#' @param object An Assay or SpatialX object in which to set data
#' @param slot Specific assay data slot to modify. For Assay objects, can be one of:
#'   \itemize{
#'     \item \code{counts}: Raw count data
#'     \item \code{data}: Normalized expression data
#'     \item \code{scale.data}: Scaled expression data
#'     \item \code{meta.data}: Cell-level metadata
#'     \item \code{cell.prop}: Cell type proportion matrix
#'     \item \code{domain.clust}: Spatial domain assignments
#'     \item \code{meta.features}: Feature-level metadata
#'     \item \code{images}: Associated image data
#'     \item \code{ident}: Cell identity labels
#'     \item \code{de}: Differential expression results
#'     \item \code{sv.genes}: Spatially variable genes
#'     \item \code{dr}: Dimensionality reduction results
#'     \item \code{svg}: Overall spatially variable genes
#'     \item \code{csvg}: Cell-type specific variable genes
#'     \item \code{dsvg}: Domain-specific variable genes
#'     \item \code{isvg}: Integrative spatially variable genes
#'     \item \code{de.truth}: Ground truth DE genes (simulations)
#'     \item \code{location}: Spatial coordinates
#'   }
#' @param new.data New data to assign to the specified slot
#' @param assay Specific assay to set data for (for SpatialX objects). Defaults to
#'   the \link{DefaultAssay}
#' @param ... Additional arguments passed to methods
#'
#' @return Returns the modified object with updated data in the specified slot
#'
#' @details
#' The SetAssayData functions provide a unified interface for modifying data
#' stored in Assay and SpatialX objects. Key features:
#' \itemize{
#'   \item Consistent interface for modifying different data types
#'   \item Automatic validation and preprocessing of input data
#'   \item Feature name sanitization (replacing underscores with dashes)
#'   \item Support for both Assay and SpatialX objects
#'   \item Preservation of object integrity during modifications
#' }
#'
#' For data matrices (counts, data, scale.data), the function automatically
#' replaces underscores in feature names with dashes to maintain compatibility
#' with downstream analysis functions. Spatial coordinates and other non-matrix
#' data are set without this transformation.
#'
#' @examples
#' \dontrun{
#' # Set data in an Assay object
#' assay_obj <- pbmc_small[["RNA"]]
#' 
#' # Set normalized data
#' new_normalized <- log1p(GetAssayData(assay_obj, slot = "counts"))
#' assay_obj <- SetAssayData(assay_obj, slot = "data", new.data = new_normalized)
#' 
#' # Set spatial coordinates
#' new_coords <- data.frame(x = runif(ncol(assay_obj)), y = runif(ncol(assay_obj)))
#' assay_obj <- SetAssayData(assay_obj, slot = "location", new.data = new_coords)
#' 
#' # Set cell metadata
#' new_metadata <- data.frame(
#'   cluster = sample(1:3, ncol(assay_obj), replace = TRUE),
#'   row.names = colnames(assay_obj)
#' )
#' assay_obj <- SetAssayData(assay_obj, slot = "meta.data", new.data = new_metadata)
#' 
#' # Set data in a SpatialX object
#' # Modify default assay data
#' spatialx_obj <- SetAssayData(spatialx_obj, slot = "counts", new.data = new_counts)
#' 
#' # Modify specific assay data
#' spatialx_obj <- SetAssayData(
#'   spatialx_obj, 
#'   slot = "data", 
#'   new.data = atac_normalized, 
#'   assay = "ATAC"
#' )
#' 
#' # Set analysis results
#' de_results <- FindMarkers(spatialx_obj, ident.1 = "cluster1", ident.2 = "cluster2")
#' spatialx_obj <- SetAssayData(spatialx_obj, slot = "de", new.data = de_results)
#' 
#' # Set spatial analysis results
#' spatialx_obj <- SetAssayData(
#'   spatialx_obj, 
#'   slot = "cell.prop", 
#'   new.data = deconvolution_results
#' )
#' }
#'
#' @seealso
#' \code{\link{GetAssayData}}, \code{\link{Assay-class}}, \code{\link{SpatialX-class}}
#'
#' @name AssayData
#' @rdname AssayData
#' @export
SetAssayData <- function(object, ...) {
  UseMethod(generic = 'SetAssayData', object = object)
}

#' @rdname AssayData
#' @export
#' @method SetAssayData Assay
#'
SetAssayData.Assay <- function(object,
  new.data,
  slot = c('data', 
	'scale.data', 
	'counts',
	'meta.data',
	'cell.prop',
	'domain.clust',
	'meta.features',
	'images',
	'ident',
	'dr',
	'de',
	'sv.genes',
	'svg',
	'csvg',
	'dsvg',
	'isvg',
	'de.truth',
	'location'), ...) {
  
	slot <- slot[1]
	slot <- match.arg(arg = slot)
	if(slot == "location"){
	  ## set the results
	  slot(object = object, name = slot) <- new.data
	}else{
	  if (!IsMatrixEmpty(x = new.data)) {
	    if (any(grepl(pattern = '_', x = rownames(x = new.data)))) {
	      warning(
	        "Feature names cannot have underscores ('_'), replacing with dashes ('-')",
	        call. = FALSE,
	        immediate. = TRUE)
	      
	      rownames(x = new.data) <- gsub(
	        pattern = '_',
	        replacement = '-',
	        x = rownames(x = new.data)
	      )
	    }## end fi
	  }## end fi
	  
	  ## set the results
	  slot(object = object, name = slot) <- new.data
	}## end fi
	
	## return results
	return(object)
}## end func

#' @rdname AssayData
#' @export
#' @method SetAssayData SpatialX
#'
SetAssayData.SpatialX <- function(
  object,
  slot = 'data',
  new.data,
  assay = NULL, ...) {
  
	assay <- assay %||% DefaultAssay(object = object)
	object@assays[[assay]] <- SetAssayData(
		object = object@assays[[assay]],
		slot = slot,
		new.data = new.data, ...)
	## return the object
	return(object)
}## end func

#' @param new.data New assay data to add
#'
#' @return \code{SetAssayData}: \code{object} with the assay data set
#'
#' @rdname AssayData
#' @export SetAssayData
#'
#' @order 2
#'
#' @export
SetAssayData <- function(object, ...) {
	UseMethod(generic = 'SetAssayData', object = object)
}## end func


#' @rdname AssayData
#' @export
GetAssay <- function(object, ...) {
  UseMethod(generic = 'GetAssay', object = object)
}


#' Get Assay from SpatialX object
#'
#' @param object A SpatialX object
#' @param assay Assay to get (default: default assay)
#' @param ... Additional arguments
#'
#' @return Returns the specified Assay object
#'
#' @rdname AssayData
#' @concept objects
#' @export
#' @method GetAssay SpatialX
#'
#' @examples
#' \dontrun{
#' data("pbmc_small")
#' GetAssay(object = pbmc_small, assay = "RNA")
#' }
#'
GetAssay.SpatialX <- function(object, assay = NULL, ...) {
	assay <- assay %||% DefaultAssay(object = object)
	object.assays <- names(object@assays)
	if (!assay %in% object.assays) {
		stop(paste0(assay,
		  " is not an assay present in the given object. Available assays are: ",
		  paste(object.assays, collapse = ", ")
		))
	}## end fi
	return(slot(object = object, name = 'assays')[[assay]])
}## end func



#' object-dimensions Number of cells and features for the active assay
#' @param x A SpatialX or Assay object
#' @param ... Additional arguments passed to methods
#'
#' @return A numeric vector with the dimensions
#'
#' @export
#' @method dim SpatialX
#'
dim.SpatialX <- function(x, ...) {
	return(dim(slot(object = x[[DefaultAssay(object = x)]], name = "counts")))
}## end func


#' object-dimensions Number of cells and features for an Assay object
#' @param x A SpatialX or Assay object
#' @param ... Additional arguments passed to methods
#'
#' @return A numeric vector with the dimensions
#'
#' @export
#' @method dim Assay
#'
dim.Assay <- function(x, ...) {
  return(dim(slot(object = x, name = "counts")))
}## end func



#' object-dimensions Cell and feature names for the active assay
#' in a SpatialX object
#' @param x A SpatialX or Assay object
#' @param ... Additional arguments passed to methods
#' @export
#' @method dimnames SpatialX
#'
dimnames.SpatialX <- function(x, ...) {
	return(dimnames(slot(object = x[[DefaultAssay(object = x)]], name = "counts")))
}## end func


#' object-dimensions Cell and feature names for an Assay object
#' @param x A SpatialX or Assay object
#' @param ... Additional arguments passed to methods
#' @export
#' @method dimnames Assay
#'
dimnames.Assay <- function(x, ...) {
  return(dimnames(slot(object = x, name = "counts")))
}## end func


#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Internal
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#' Create a SpatialX object from counts, location, and metadata
#'
#' This function creates a SpatialX object by combining count data, spatial coordinates,
#' and optional metadata into a structured object for spatial analysis. It performs
#' data validation, filtering, and initializes the object with proper slot assignments.
#'
#' @param counts A count matrix, data.frame, or matrix-like object with features as rows
#'               and cells/spots as columns. Can contain raw counts or normalized data.
#' @param location Spatial coordinates as a data.frame or matrix with rows corresponding
#'                 to cells/spots and columns for spatial coordinates (typically x and y).
#'                 Row names should match column names of the counts matrix.
#' @param meta.data Optional cell-level metadata as a data.frame with rows corresponding
#'                  to cells and columns containing additional information about each cell.
#' @param names.field Field index in cell names containing sample information for
#'                   initial identity assignment (default: 1).
#' @param names.delim Delimiter used in cell names to separate fields (default: '_').
#' @param min.cells Include features detected in at least this many cells. Features
#'                  with fewer detected cells will be filtered out (default: 0).
#' @param pct.cells Minimum percentage of cells in which a feature must be detected
#'                  to be included (default: 0.005).
#' @param min.umi Minimum UMI counts per cell. Cells with fewer UMIs will be
#'                filtered out (default: 10).
#' @param num.core Number of CPU cores to use for parallel processing (default: 1).
#' @param min.features Include cells where at least this many features are detected.
#'                     Cells with fewer features will be filtered out (default: 0).
#' @param row.names Optional vector of feature names to use when \code{counts} is a
#'                  \code{data.frame} or \code{data.frame}-derived object without row names.
#'
#' @return Returns a \code{\link{SpatialX}} object containing the provided count data,
#'         spatial coordinates, metadata, and initialized slots for spatial analysis.
#'
#' @details
#' This function serves as a comprehensive constructor for SpatialX objects, providing:
#' \itemize{
#'   \item Data validation and integrity checks
#'   \item Quality control filtering based on multiple criteria
#'   \item Automatic extraction of sample identities from cell names
#'   \item Integration of spatial coordinates with count data
#'   \item Proper initialization of all object slots
#' }
#'
#' The function performs the following steps:
#' \enumerate{
#'   \item Validates input dimensions and row/column name consistency
#'   \item Applies quality control filters to remove low-quality cells and features
#'   \item Extracts initial cell identities from cell names using specified field and delimiter
#'   \item Creates an Assay object with the filtered count data
#'   \item Integrates spatial coordinates and metadata
#'   \item Initializes the SpatialX object with proper slot assignments
#' }
#'
#' @examples
#' \dontrun{
#' # Create a SpatialX object from basic components
#' counts <- matrix(rpois(1000, 5), nrow = 100, ncol = 10)
#' rownames(counts) <- paste0("Gene_", 1:100)
#' colnames(counts) <- paste0("Sample1_Cell_", 1:10)
#' 
#' locations <- data.frame(x = runif(10), y = runif(10))
#' rownames(locations) <- colnames(counts)
#' 
#' # Create object with default parameters
#' spatialx_obj <- CreateAssayObjectEach(
#'   counts = counts,
#'   location = locations
#' )
#'
#' # Create object with metadata and filtering
#' cell_metadata <- data.frame(
#'   batch = rep("batch1", 10),
#'   condition = sample(c("ctrl", "trt"), 10, replace = TRUE),
#'   row.names = colnames(counts)
#' )
#' 
#' spatialx_obj <- CreateAssayObjectEach(
#'   counts = counts,
#'   location = locations,
#'   meta.data = cell_metadata,
#'   min.cells = 3,
#'   min.features = 100,
#'   names.field = 1,
#'   names.delim = "_"
#' )
#' }
#'
#' @seealso
#' \code{\link{SpatialX-class}}, \code{\link{CreateSpatialXObject}},
#' \code{\link{CreateAssayObject}}, \code{\link{ExtractField}}
#'
#' @describeIn SpatialX Create a SpatialX object using counts, location, and metadata
#' @export
#' 
CreateAssayObjectEach <- function(counts, 
                             location,
                             meta.data = NULL,
                             names.field = 1,
                             names.delim = "_",
                             min.cells = 0,
                             pct.cells = 0.005,
                             min.umi = 10,
                             num.core = 1,
                             min.features = 0,
                             row.names = NULL){
  ## add location information
  if (!is.null(x = location)) {
    if (!all(rownames(x = location) %in% colnames(x = counts))) {
      warning("Some cells in location not present in provided counts matrix")
    }## end fi
  }## end funcs
  
  ## set idents
  idents <- factor(x = unlist(x = lapply(X = colnames(x = counts), 
                                         FUN = ExtractField, 
                                         field = names.field, 
                                         delim = names.delim)))
  
  ## change count names if doing integrative analysis of multiple assays
  #rownames(location) <- paste0(colnames(counts),".", assay)
 # colnames(counts) <- paste0(colnames(counts),".", assay)
  
  ## create assay data
  assay.data <- CreateAssayObject(counts = counts, 
                                  min.cells = min.cells,
                                  pct.cells = pct.cells,
                                  min.umi = min.umi,
                                  min.features = min.features, 
                                  row.names = row.names, 
                                  num.core = num.core)
  assay.data@ident <- idents
  
  ## spatial location information proprecess
  if (!is.null(x = location)) {
    common.cells <- intersect(x = rownames(x = location), y = colnames(x = assay.data))
    location <- location[common.cells, , drop = FALSE]
    ## scale locations, might be necessary in practice
    location <- as.data.frame(scale(location))
  }## end funcs
  ## Create assay data
  slot(assay.data, name = "location") <- location
  
  
  if(!is.null(meta.data)){
    assay.data <- AddMetaData(assay.data, meta.data = meta.data)
  }## end fi
  
  return(assay.data)
}## end func


#' Internal metadata and object accessor functions
#'
#' These internal functions provide the underlying implementation for metadata
#' manipulation and object access in SpatialX and Assay objects. They handle
#' data validation, slot access, and error checking for the user-facing functions.
#'
#' @param object A SpatialX or Assay object
#' @param meta.data Metadata to add (vector, list, or data.frame)
#' @param col.name Name for the metadata column if not already named
#' @param x A SpatialX or Assay object
#' @param i,j Indices for subsetting (features and cells respectively)
#' @param n Number of rows to return for head/tail functions
#' @param ... Additional arguments passed to methods
#'
#' @return Various returns depending on the function:
#' \itemize{
#'   \item \code{.AddMetaData}: Object with metadata added
#'   \item \code{head.SpatialX}, \code{tail.SpatialX}: First/last n rows of metadata
#'   \item \code{[[.SpatialX}: Metadata, assay, or slot data depending on \code{i}
#'   \item \code{[.Assay}: Subset of assay data
#'   \item \code{[[.Assay}: Feature-level metadata
#' }
#'
#' @details
#' These functions provide the core functionality for:
#' \itemize{
#'   \item Adding metadata to objects with proper validation
#'   \subsetting and extracting data from objects
#'   \item Accessing specific slots and components
#'   \item Providing head/tail views of metadata
#' }
#'
#' The \code{[[} operator for SpatialX objects is particularly powerful and can:
#' \itemize{
#'   \item Return all metadata columns if \code{i} is missing
#'   \item Return specific metadata columns by name
#'   \item Return entire assays by name
#'   \item Access specific slots from the active assay
#' }
#'
#' @keywords internal
#' @export .AddMetaData
#' @noRd
#'
.AddMetaData <- function(object, meta.data, col.name = NULL) {
  
	if (is.null(x = col.name) && is.atomic(x = meta.data)) {
		stop("'col.name' must be provided for atomic meta.data types (eg. vectors)")
	}## end fi
  
  ## to be data frame
	if (inherits(x = meta.data, what = c('matrix', 'Matrix'))) {
		meta.data <- as.data.frame(x = meta.data)
	}## end fi
  
	col.name <- col.name %||% names(x = meta.data) %||% colnames(x = meta.data)
	if (is.null(x = col.name)) {
		stop("No meta.data name provided and could not infer it from meta.data object")
	}## end fi
	
	## original meta data
	old_metadata <- slot(object[[object@active.assay]], name="meta.data")
	old_metadata[[col.name]] <- meta.data
	
	## update meta data
	object@assays[[object@active.assay]]@meta.data <- old_metadata
	
	return(object)
}## end funcs

# Assign internal function to method
AddMetaData.SpatialX <- .AddMetaData



#' SpatialX object
#' @param x A SpatialX or Assay object
#' @param ... Additional arguments passed to methods
#' 
#' @rdname head
#' @keywords internal
#' @noRd
#' @export .head
#' 
.head <- function(x, n = 10L, ...) {
	return(head(x = x[[]], n = n, ...))
}## end funcs

#' SpatialX-class Get the first rows of cell-level metadata
#'
#' @param x A SpatialX object
#' @param n Number of rows to return
#' @param ... Additional arguments passed to \code{\link[utils]{head}}
#'
#' @return \code{head}: The first \code{n} rows of cell-level metadata
#'
#' @export
#' @method head SpatialX
#'
#' @examples
#' \dontrun{
#' # Get the first 10 rows of cell-level metadata
#' head(spatialx_obj)
#' 
#' # Get first 5 rows
#' head(spatialx_obj, n = 5)
#' }
head.SpatialX <- .head


#' tail SpatialX object
#' @rdname tail
#' @keywords internal
#' 
#' @export .tail
#' 
#' @noRd
#' 
.tail <- function(x, n = 10L, ...) {
	return(tail(x = x[[]], n = n, ...))
}## end funcs

#' SpatialX-class Get the last rows of cell-level metadata
#'
#' @param x A SpatialX object
#' @param n Number of rows to return
#' @param ... Additional arguments passed to \code{\link[utils]{tail}}
#'
#' @return \code{tail}: The last \code{n} rows of cell-level metadata
#'
#' @export
#' @method tail SpatialX
#'
#' @examples
#' \dontrun{
#' # Get the last 10 rows of cell-level metadata
#' tail(spatialx_obj)
#' 
#' # Get last 5 rows
#' tail(spatialx_obj, n = 5)
#' }
#'
tail.SpatialX <- .tail

#' SpatialX-class Extract metadata, assays, or slot data
#'
#' @param x A SpatialX object
#' @param i Metadata column name(s), assay name, or slot name
#' @param drop Logical indicating whether to drop to lowest possible dimension
#' @param ... Additional arguments passed to methods
#'
#' @return \code{[[}: 
#' \itemize{
#'   \item If \code{i} is missing: all metadata columns
#'   \item If \code{i} is metadata column name(s): data.frame with requested metadata
#'   \item If \code{i} is assay name: the requested Assay object
#'   \item If \code{i} is slot name: data from the specified slot in active assay
#' }
#'
#' @importFrom methods slotNames
#' @importFrom methods slot
#' @export
#' @method [[ SpatialX
#'
#' @examples
#' \dontrun{
#' # Get all metadata
#' all_metadata <- spatialx_obj[[]]
#' 
#' # Get specific metadata columns
#' clusters <- spatialx_obj[["cluster"]]
#' multiple_cols <- spatialx_obj[[c("cluster", "condition")]]
#' 
#' # Get an assay
#' rna_assay <- spatialx_obj[["RNA"]]
#' 
#' # Get slot data from active assay
#' counts_data <- spatialx_obj[["counts"]]
#' spatial_coords <- spatialx_obj[["location"]]
#' }
#'
"[[.SpatialX" <- function(x, i, ..., drop = FALSE) {
	
	if (missing(x = i)) {
		i <- colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data'))
	}## end fi
	
  if (length(x = i) == 0) {
		return(data.frame(row.names = colnames(x = x)))
	} else if (length(x = i) > 1 || any(i %in% colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data')))) {
		if (any(!i %in% colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data')))) {
		  warning("Cannot find the following bits of meta data: ",	paste0(i[!i %in% colnames(x = slot(object = x, name = 'meta.data'))],
			  collapse = ', ')
		  )
		}## end fi
		i <- i[i %in% colnames(x = slot(object = x@assays[[x@active.assay]], name = 'meta.data'))]
		data.return <- slot(object = x@assays[[x@active.assay]], name = 'meta.data')[, i, drop = FALSE, ...]
		if (drop) {
			data.return <- unlist(x = data.return, use.names = FALSE)
			names(x = data.return) <- rep.int(x = colnames(x = x), times = length(x = i))
		}## end fi
	} else if (length(x = i) > 1 || any(i %in% names(x = x@assays))) {
		## here are two possible name to extract the values
		## extract the assay
		data.return <- x@assays[[i]]
		
	} else {	
	
		slot.use <- ifelse(i %in% slotNames(x = x@assays[[x@active.assay]]), i, NULL)
	  
		if (is.null(x = slot.use)) {
			stop("Cannot find '", i, "' in this SpatialX object", call. = FALSE)
		}## end fi
		data.return <- slot(object = x@assays[[x@active.assay]], name = slot.use)
	}## end fi
	return(data.return)
}## end funcs


#' Assay-class Subset assay data
#'
#' @param x An Assay object
#' @param i Feature indices or names
#' @param j Cell indices or names
#' @param ... Additional arguments passed to methods
#'
#' @return \code{[}: The \code{data} slot for features \code{i} and cells \code{j}
#'
#' @export
#' @method [ Assay
#'
#' @examples
#' \dontrun{
#' # Subset assay by features and cells
#' subset_data <- assay_obj[1:10, 1:5]
#' 
#' # Subset by feature names
#' specific_genes <- assay_obj[c("Gene1", "Gene2"), ]
#' 
#' # Subset by cell names
#' specific_cells <- assay_obj[, c("Cell1", "Cell2")]
#' }
#'
#'
"[.Assay" <- function(x, i, j, ...) {
  if (missing(x = i)) {
    i <- seq_len(length.out = nrow(x = x))
  }## end fi
  
  if (missing(x = j)) {
    j <- seq_len(length.out = ncol(x = x))
  }# end fi
  
  return(GetAssayData(object = x)[i, j, ..., drop = FALSE])
}## end funcs


#' Assay-class Extract feature-level metadata
#'
#' @param x An Assay object
#' @param i Metadata column name(s)
#' @param drop Logical indicating whether to drop to lowest possible dimension
#' @param ... Additional arguments passed to methods
#'
#' @return \code{[[}: The feature-level metadata for column(s) \code{i}
#'
#' @export
#' @method [[ Assay
#'
#' @examples
#' \dontrun{
#' # Get all feature metadata
#' all_feature_meta <- assay_obj[[]]
#' 
#' # Get specific feature metadata column
#' gene_names <- assay_obj[["gene_name"]]
#' 
#' # Get multiple feature metadata columns
#' multiple_cols <- assay_obj[[c("gene_name", "chromosome")]]
#' }
#'
"[[.Assay" <- function(x, i, ..., drop = FALSE) {
  if (missing(x = i)) {
    i <- colnames(x = slot(object = x, name = 'meta.features'))
  }
  data.return <- slot(object = x, name = 'meta.features')[, i, drop = FALSE, ...]
  if (drop) {
    data.return <- unlist(x = data.return, use.names = FALSE)
    names(x = data.return) <- rep.int(x = rownames(x = x), times = length(x = i))
  }
  return(data.return)
}## end func


#' Set default values based on NULL conditions
#'
#' These operators provide convenient ways to set default values when working with
#' potentially NULL objects. They are particularly useful for function parameters
#' and variable assignments where fallback values are needed.
#'
#' @param x An object to test for NULL
#' @param y A default value to use if conditions are met
#'
#' @return 
#' \itemize{
#'   \item \code{\%||\%}: Returns \code{y} if \code{x} is \code{NULL}, otherwise returns \code{x}
#'   \item \code{\%iff\%}: Returns \code{y} if \code{x} is \strong{not} \code{NULL}, otherwise returns \code{x} (which is \code{NULL})
#' }
#'
#' @details
#' These operators provide concise syntax for common conditional assignment patterns:
#' 
#' \describe{
#'   \item{\code{\%||\%}}{Useful for providing default values when an object might be NULL}
#'   \item{\code{\%iff\%}}{Useful for conditionally computing values only when needed}
#' }
#'
#' The \code{\%||\%} operator is imported from the \code{rlang} package and follows
#' the same behavior. The \code{\%iff\%} operator is a complementary utility that
#' provides the inverse logic.
#'
#' @examples
#' # Basic usage of %||%
#' NULL %||% "default_value"  # Returns "default_value"
#' "existing_value" %||% "default_value"  # Returns "existing_value"
#'
#' # Practical examples with function parameters
#' process_data <- function(data = NULL) {
#'   data <- data %||% read.csv("default_data.csv")
#'   # Process data...
#' }
#'
#' # Using %||% with list elements
#' my_list <- list(a = 1, b = NULL)
#' my_list$a %||% 100  # Returns 1
#' my_list$b %||% 100  # Returns 100
#' my_list$c %||% 100  # Returns 100 (non-existent element)
#'
#' # Basic usage of %iff%
#' "not_null" %iff% "computed_value"  # Returns "computed_value"
#' NULL %iff% "computed_value"        # Returns NULL
#'
#' # Practical example with expensive computation
#' compute_expensive <- function(x) {
#'   x %iff% expensive_calculation(x)
#' }
#'
#' # Using %iff% to conditionally add metadata
#' add_metadata <- function(obj, clusters) {
#'   obj$clusters <- clusters %iff% find_clusters(obj)
#'   return(obj)
#' }
#'
#' # Combining both operators
#' config <- list(threshold = NULL)
#' threshold <- config$threshold %||% 0.5
#' result <- threshold %iff% process_data(threshold)
#'
#' @name set-if-null
#' @rdname set-if-null
#' 
## @importFrom rlang %||%
#' 
#' @export
#'
#' @concept utils
#'
rlang::`%||%`

#' 
#' @rdname set-if-null
#' @export
#'
`%iff%` <- function(x, y) {
  if (!rlang::is_null(x = x)) {
    return(y)
  }
  return(x)
}

