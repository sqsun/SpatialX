# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

rcpp_hello_world <- function() {
    .Call('_SpatialX_rcpp_hello_world', PACKAGE = 'SpatialX')
}


#' Fast compute the testing quantities without covariates, double format
#' input all genes at a time
#' include the loop number of gene in Cpp file
#' @param Yin Working vector
#' @param Din Weight for each gene
#' @param locationin Location for each cell
#' @param kernel_paramin Gaussian kernel parameters
#' @param tauin Initial value for variance component
#' @param kernel_typein The kernel type, including 'gaussian', 'linear' and 'cosine'
#' 
#' @return A list
#' 
#' 
#' @export
fastComputeQuantitiesWithoutCVT <- function(Yin, locationin, kernel_paramin, Din, tauin, kernel_typein) {
    .Call('_SpatialX_fastComputeQuantitiesWithoutCVT', PACKAGE = 'SpatialX', Yin, locationin, kernel_paramin, Din, tauin, kernel_typein)
}

#' Compute the testing quantities without covariates, float format
#' @param yin Working vector
#' @param Pyin The vector P*y
#' @param cov_matin Kernel matrix to be tested
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' 
#' @return A list
#' 
#' 
#' @export
ComputeTestQuantRcpp_nocov <- function(yin, Pyin, cov_matin, Din, tauin) {
    .Call('_SpatialX_ComputeTestQuantRcpp_nocov', PACKAGE = 'SpatialX', yin, Pyin, cov_matin, Din, tauin)
}

#' Variance component estimation with covariates using Average Information algorithm
#' @param Yin Working vector
#' @param Xin Covariate matrix
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' @param fixtauin Variance component to be optimized
#' @param tolin Tolerance
#' 
#' @return A list
#' 
#' @export
CovariatesAI <- function(Yin, Xin, Din, tauin, fixtauin, tolin) {
    .Call('_SpatialX_CovariatesAI', PACKAGE = 'SpatialX', Yin, Xin, Din, tauin, fixtauin, tolin)
}

#' Variance component estimation without covariates using Average Information algorithm, float format
#' @param Yin Working vector
#' @param Xin Covariate matrix
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' @param fixtauin Variance component to be optimized
#' @param tolin Tolerance
#' 
#' @return A list
#' 
#' 
#' @export
noCovariatesAI <- function(Yin, Xin, Din, tauin, fixtauin, tolin) {
    .Call('_SpatialX_noCovariatesAI', PACKAGE = 'SpatialX', Yin, Xin, Din, tauin, fixtauin, tolin)
}

#' Compute the testing quantities with covariates, fast trace term
#' @param Xin covariates
#' @param Pyin The vector P*y
#' @param Kin Kernel matrix to be tested
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' 
#' @return A list
#' 
#' 
#' @export
FastTraceComputeTestQuantRcpp_cov <- function(Pyin, Xin, Kin, Din, tauin) {
    .Call('_SpatialX_FastTraceComputeTestQuantRcpp_cov', PACKAGE = 'SpatialX', Pyin, Xin, Kin, Din, tauin)
}

#' Compute the testing quantities with covariates, float format
#' @param yin Working vector
#' @param Pyin The vector P*y
#' @param Xin Covariate matrix, including the intercept
#' @param cov_matin Kernel matrix to be tested
#' @param Din Weight for each gene
#' @param tauin Initial value for variance component
#' 
#' @return A list
#' 
#' 
#' @export
ComputeTestQuantRcpp_cov <- function(yin, Pyin, Xin, cov_matin, Din, tauin) {
    .Call('_SpatialX_ComputeTestQuantRcpp_cov', PACKAGE = 'SpatialX', yin, Pyin, Xin, cov_matin, Din, tauin)
}

#' Compute Gaussian kernel parameters
#' @param xin spatial location
#' 
#' @return A list
#' 
#' 
#' @export
ComputeKernelParamLessMem <- function(xin) {
    .Call('_SpatialX_ComputeKernelParamLessMem', PACKAGE = 'SpatialX', xin)
}

#' Compute the testing quantities for linear mixed model, float format
#' @param covariatesin Covariates matrix
#' @param Xdaggerin The inverse matrix of covariates
#' @param norm_countsin normalized count matrix
#' @param cov_matin Kernel matrix to be testedt
#' 
#' @return A list
#' 
#' 
#' @export
ComputeTestQuantRcpp_RLSKAT <- function(cov_matin, Xdaggerin, covariatesin, norm_countsin) {
    .Call('_SpatialX_ComputeTestQuantRcpp_RLSKAT', PACKAGE = 'SpatialX', cov_matin, Xdaggerin, covariatesin, norm_countsin)
}

#' Compute Euclidean distance matrix by rows
#' @param x A location matrix
ED_cpp <- function(x) {
    .Call('_SpatialX_ED_cpp', PACKAGE = 'SpatialX', x)
}

#' Do inverse of sysmetric matrix 
#' @param Min A sysmetric matrix
#' 
#' @return A list
#' 
#' @export
MatrixInverse <- function(Min) {
    .Call('_SpatialX_MatrixInverse', PACKAGE = 'SpatialX', Min)
}

#' Do inverse of sysmetric matrix 
#' @param Min A sysmetric matrix
#' 
#' @return A list
#' 
#' @export
SysMatEigen <- function(Min) {
    .Call('_SpatialX_SysMatEigen', PACKAGE = 'SpatialX', Min)
}

#' Do inverse of sparse sysmetric matrix 
#' @param Min A sysmetric matrix
#' @param num_topin The number of top eigen values
#' 
#' @return A list
#' 
#' @export
SparseSysMatEigen <- function(Min, num_topin) {
    .Call('_SpatialX_SparseSysMatEigen', PACKAGE = 'SpatialX', Min, num_topin)
}

LogLSFactorCpp <- function(data, scale_factor, display_progress = TRUE) {
    .Call('_SpatialX_LogLSFactorCpp', PACKAGE = 'SpatialX', data, scale_factor, display_progress)
}

LogSizeFactorCpp <- function(data, size_factor, pseudo_count, display_progress = TRUE) {
    .Call('_SpatialX_LogSizeFactorCpp', PACKAGE = 'SpatialX', data, size_factor, pseudo_count, display_progress)
}

FastSparseRowScaleData <- function(mat, scale = TRUE, center = TRUE, scale_max = 10, display_progress = TRUE) {
    .Call('_SpatialX_FastSparseRowScaleData', PACKAGE = 'SpatialX', mat, scale, center, scale_max, display_progress)
}

FastRowScaleData <- function(mat, display_progress = TRUE) {
    .Call('_SpatialX_FastRowScaleData', PACKAGE = 'SpatialX', mat, display_progress)
}

#' Compute Euclidean distance matrix by columns
#'
#' Used in sc3-funcs.R distance matrix calculation
#' and within the consensus clustering.
#'
#' @param x A numeric matrix.
ED2 <- function(x) {
    .Call('_SpatialX_ED2', PACKAGE = 'SpatialX', x)
}

#' compute D-alpha*W for CAR prior
#'
#'
#' @param A symmetric matrix
#' @param sigma Kernel parameter
#' @param alpha Tunning parameter
#' @param thr_car Threashold to cut
#' @export
ComputeDmW <- function(A, sigma, alpha, thr_car) {
    .Call('_SpatialX_ComputeDmW', PACKAGE = 'SpatialX', A, sigma, alpha, thr_car)
}

Standardize <- function(mat, display_progress = TRUE) {
    .Call('_SpatialX_Standardize', PACKAGE = 'SpatialX', mat, display_progress)
}

FastRowVar <- function(x) {
    .Call('_SpatialX_FastRowVar', PACKAGE = 'SpatialX', x)
}

FastRowMean <- function(x) {
    .Call('_SpatialX_FastRowMean', PACKAGE = 'SpatialX', x)
}

FastSparseRowVar <- function(mat) {
    .Call('_SpatialX_FastSparseRowVar', PACKAGE = 'SpatialX', mat)
}

FastSparseRowMean <- function(mat) {
    .Call('_SpatialX_FastSparseRowMean', PACKAGE = 'SpatialX', mat)
}

sp_means_Rcpp <- function(sp_data, rowMeans = FALSE) {
    .Call('_SpatialX_sp_means_Rcpp', PACKAGE = 'SpatialX', sp_data, rowMeans)
}

sp_sums_Rcpp <- function(sp_data, rowSums = FALSE) {
    .Call('_SpatialX_sp_sums_Rcpp', PACKAGE = 'SpatialX', sp_data, rowSums)
}

sp_vars_Rcpp <- function(sp_data, rowVars = FALSE) {
    .Call('_SpatialX_sp_vars_Rcpp', PACKAGE = 'SpatialX', sp_data, rowVars)
}

