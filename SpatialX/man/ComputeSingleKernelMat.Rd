% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilties.R
\name{ComputeSingleKernelMat}
\alias{ComputeSingleKernelMat}
\title{Compute single kernel matrix}
\usage{
ComputeSingleKernelMat(
  x1 = NULL,
  x2 = NA,
  ED = NULL,
  kernel.type = NULL,
  kernel.params = NA,
  sparse = FALSE,
  num.core = 5,
  check.positive = FALSE,
  tol = 0.001
)
}
\arguments{
\item{x1}{Primary data matrix for kernel computation. Rows represent samples
and columns represent features. Required unless ED is provided.}

\item{x2}{Optional secondary data matrix for cross-kernel computation.
If NA (default), computes kernel within x1 (self-similarity).}

\item{ED}{Precomputed Euclidean distance matrix. If provided, skips distance
computation and uses this matrix directly.}

\item{kernel.type}{Type of kernel to compute. Options: "gaussian" (RBF),
"poly" (polynomial), "linear", "car" (Conditional Autoregressive),
"cosine", "matern", or "spline". Default is "gaussian".}

\item{kernel.params}{Parameters for the kernel function. For Gaussian kernel,
this is the bandwidth parameter; for polynomial, the degree; etc.
If NA, automatically computed using \code{ComputeKernelParamLessMem}.}

\item{sparse}{Logical indicating whether to compute sparse kernel matrix.
Useful for large datasets to save memory. Default is FALSE.}

\item{num.core}{Number of CPU cores to use for parallel computation when
\code{sparse = TRUE}. Default is 5.}

\item{check.positive}{Logical indicating whether to check and ensure the
kernel matrix is positive definite. Default is FALSE.}

\item{tol}{Tolerance threshold for sparse matrix computation. Elements below
this value are treated as zero. Default is 1e-3.}
}
\value{
Returns a kernel matrix of the specified type. The matrix can be
        dense or sparse depending on the \code{sparse} parameter. For
        self-similarity kernels, returns a square symmetric matrix.
}
\description{
This function computes various types of kernel matrices for spatial analysis,
machine learning, and statistical modeling. It supports multiple kernel types
including Gaussian (RBF), polynomial, linear, CAR (Conditional Autoregressive),
cosine, Matern, and spline kernels, with options for sparse matrix computation
and parallel processing.
}
\details{
This function provides a unified interface for computing various kernel
matrices commonly used in spatial statistics, machine learning, and
genomic analysis. Key features:

\itemize{
  \item \strong{Multiple Kernel Types}:
    \itemize{
      \item \code{gaussian}: Radial Basis Function (RBF) kernel
      \item \code{poly}: Polynomial kernel
      \item \code{linear}: Linear kernel (dot product)
      \item \code{car}: Conditional Autoregressive kernel for spatial data
      \item \code{cosine}: Cosine similarity kernel
      \item \code{matern}: Matern covariance kernel for spatial data
      \item \code{spline}: Thin plate spline kernel
    }
  \item \strong{Automatic Parameter Tuning}: When \code{kernel.params} is NA,
        automatically computes appropriate parameters based on the data.
  \item \strong{Sparse Computation}: Option to compute sparse kernels for
        memory efficiency with large datasets.
  \item \strong{Parallel Processing}: Supports parallel computation for
        sparse kernel matrices.
  \item \strong{Data Preprocessing}: Automatically scales and centers input data.
}

The function automatically handles data preprocessing by scaling and centering
the input matrices. For spatial kernels (CAR, Matern, spline), the function
assumes the input represents spatial coordinates.
}
\examples{
\dontrun{
# Generate sample data
data_matrix <- matrix(rnorm(100), nrow = 10, ncol = 10)
spatial_coords <- matrix(runif(20), ncol = 2)

# Compute Gaussian (RBF) kernel
gaussian_kernel <- ComputeSingleKernelMat(
  x1 = data_matrix,
  kernel.type = "gaussian",
  kernel.params = 1.0
)

# Compute sparse Gaussian kernel with parallel processing
sparse_gaussian <- ComputeSingleKernelMat(
  x1 = data_matrix,
  kernel.type = "gaussian",
  sparse = TRUE,
  num.core = 4,
  tol = 1e-4
)

# Compute polynomial kernel
poly_kernel <- ComputeSingleKernelMat(
  x1 = data_matrix,
  kernel.type = "poly",
  kernel.params = 3
)

# Compute CAR kernel for spatial data
car_kernel <- ComputeSingleKernelMat(
  x1 = spatial_coords,
  kernel.type = "car",
  kernel.params = 0.5
)

# Compute Matern kernel
matern_kernel <- ComputeSingleKernelMat(
  x1 = spatial_coords,
  kernel.type = "matern",
  kernel.params = 1.5
)

# Use precomputed distance matrix
dist_matrix <- as.matrix(dist(data_matrix))
kernel_from_dist <- ComputeSingleKernelMat(
  ED = dist_matrix,
  kernel.type = "gaussian",
  kernel.params = 1.0
)
}

}
\seealso{
\code{\link{ComputeKernelParamLessMem}}, \code{\link{SysMatEigen}},
\code{\link{ComputeDmW}}, \code{\link{MatrixInverse}}
}
